diff -ruNb DirectFB-1.7.7_orig/configure.in DirectFB-1.7.7/configure.in
--- DirectFB-1.7.7_orig/configure.in	2015-02-09 18:16:46.000000000 +0100
+++ DirectFB-1.7.7/configure.in	2016-07-03 13:52:09.975991523 +0200
@@ -177,6 +177,13 @@
 
 AM_CONDITIONAL(X11_CORE, test "$enable_x11" = "yes")
 
+# Check DTV library header and add definition
+AC_CHECK_HEADER( [ddi_gpu.h],
+  AC_DEFINE(GFXDRV_GPUDDI,1,[Use GPU DDI])
+  AC_DEFINE(USE_RPC4DTV,1,[Use DTV library])
+  AC_DEFINE(USE_DLOPEN,1,[Use dlopen]),
+  AC_MSG_ERROR([*** DTV library is required. ***])
+)
 
 dnl Test for X11VDPAU
 AC_ARG_ENABLE(x11vdpau,
@@ -525,6 +532,20 @@
 AC_SUBST(DIRECT_BUILD_TEXT)
 
 
+AC_ARG_ENABLE(offset,
+  [  --enable-offset           enable physical address mapping offset adjust for dev/mem and fbdev [[default=yes]]],,
+  enable_offset=yes)
+
+AM_CONDITIONAL(ENABLE_OFFSET_ADJUST, test "$enable_offset" = "yes")
+
+
+AC_ARG_ENABLE(virtualfb,
+  [  --enable-virtualfb        enable virtual front buffer support for dev/mem and fbdev [[default=no]]],,
+  enable_virtualfb=no)
+
+AM_CONDITIONAL(ENABLE_VIRTUALFB, test "$enable_virtualfb" = "yes")
+
+
 AC_ARG_ENABLE(gettid,
               AC_HELP_STRING([--enable-gettid],
                              [enable usage of gettid() @<:@default=yes@:>@]),
@@ -1433,6 +1454,14 @@
 AC_SUBST(GSTREAMER_INCL)
 
 
+dnl Allow to disable CIF support
+AC_ARG_ENABLE(cif,
+  [  --enable-cif              build CIF image provider [[default=no]]],
+  enable_cif="$enableval", enable_cif=no)
+ 
+AM_CONDITIONAL(CIF_PROVIDER, test "$enable_cif" = "yes")
+
+
 dnl Allow to disable GIF support
 AC_ARG_ENABLE(gif,
               AC_HELP_STRING([--enable-gif],
@@ -2053,6 +2082,7 @@
           vdpau)
                   checkfor_vdpau=yes
                   ;;
+
           *)
                   echo "Unknown gfxdriver $gfxdriver, exiting!"
                   exit 1
@@ -2210,6 +2240,7 @@
    fi
 fi
 
+
 # lets check for input driver
 
 checkfor_dbox2remote=no
@@ -2753,6 +2784,7 @@
 AC_SUBST(MNG_PROVIDER)
 AC_SUBST(LIBMNG)
 AC_SUBST(PNG_PROVIDER)
+AC_SUBST(CIF_PROVIDER)
 AC_SUBST(LIBPNG_CFLAGS)
 AC_SUBST(LIBPNG_LIBS)
 AC_SUBST(FREETYPE_PROVIDER)
@@ -3032,6 +3064,8 @@
   Dithering 565             $with_dither_rgb16
   zlib compression          $use_zlib                 $ZLIB_LIBS
   Using setsockopt          $with_setsockopt
+  offset adjust		          $enable_offset
+  virtual frontbuffer	      $enable_virtualfb
 
 Building Tests              $with_tests
 Building Tools              $with_tools
@@ -3058,6 +3092,7 @@
   GIF                       $enable_gif
   JPEG                      $JPEG                 $LIBJPEG
   PNG                       $PNG                  $LIBPNG_CFLAGS $LIBPNG_LIBS
+  CIF                       $enable_cif
   Imlib2                    $imlib2               $IMLIB2_CFLAGS $IMLIB2_LIBS
   PNM                       $enable_pnm
   SVG                       $svg                  $LIBSVG_CFLAGS $LIBSVG_LIBS
diff -ruNb DirectFB-1.7.7_orig/dtv_lib/ddi_gpu_data.h DirectFB-1.7.7/dtv_lib/ddi_gpu_data.h
--- DirectFB-1.7.7_orig/dtv_lib/ddi_gpu_data.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7/dtv_lib/ddi_gpu_data.h	2016-07-03 21:27:43.227959579 +0200
@@ -0,0 +1,492 @@
+#ifndef __DDI_GPU_DATA_H__
+#define __DDI_GPU_DATA_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GPU_MAX_NUMBER_OF_LAYER 4
+
+#ifndef UINT8 // If not defined, it's stand-alone client.
+#ifndef UINT8
+typedef	unsigned char			__UINT8;
+#define UINT8 __UINT8
+#endif
+
+#ifndef SINT8
+typedef	signed char				__SINT8;
+#define SINT8 __SINT8
+#endif
+
+#ifndef CHAR
+typedef	char					__CHAR;
+#define CHAR __CHAR
+#endif
+
+#ifndef UINT16
+typedef	unsigned short			__UINT16;
+#define UINT16 __UINT16
+#endif
+
+#ifndef SINT16
+typedef	signed short			__SINT16;
+#define SINT16 __SINT16
+#endif
+
+#ifndef UINT32
+typedef	unsigned long			__UINT32;
+#define UINT32 __UINT32
+#endif
+
+#ifndef SINT32
+typedef signed long				__SINT32;
+#define SINT32 __SINT32
+#endif
+
+#ifndef BOOLEAN
+typedef	unsigned long			__BOOLEAN;
+#define BOOLEAN __BOOLEAN
+#endif
+
+#ifndef UINT64
+typedef	unsigned long long		__UINT64;
+#define UINT64 __UINT64
+#endif
+
+#ifndef SINT64
+typedef	signed long long		__SINT64;
+#define SINT64 __SINT64
+#endif
+
+/**
+ * @brief This enumeration describes the API return type. 
+ */
+typedef enum 
+{
+	OK					= 0, 	/**< success (no error) */
+	NOT_OK				= -1,	/**< generic error */
+	INVALID_PARAMS		= -2, 	/**< input parameter error */
+	NOT_ENOUGH_RESOURCE	= -3,	/**< not enough resource */
+	NOT_SUPPORTED		= -4,	/**< not supported */
+	NOT_PERMITTED		= -5,	/**< not permitted */
+	TIMEOUT				= -6,	/**< timeout */
+	NO_DATA_RECEIVED	= -7,	/**< no data received */
+	DN_BUF_OVERFLOW 	= -8	/**< buffer overflow error */
+} DTV_STATUS_T;
+#endif
+
+
+/* type definitions */
+
+#ifdef _EMUL_WIN
+#define UINT8 unsigned int
+#endif
+
+/**
+ * @brief This enumeration describes the supported functions.
+ */
+typedef enum {
+	GPU_ACCEL_NONE				= 0x00000000,	/**< none of these */
+	GPU_ACCEL_FILLRECTANGLE 	= 0x00000001,	/**< DDI_GPU_FillRectangle is accelerated */
+	GPU_ACCEL_DRAWRECTANGLE 	= 0x00000002,	/**< DDI_GPU_DrawRectangle is accelerated */
+	GPU_ACCEL_DRAWLINE			= 0x00000004,	/**< DDI_GPU_DrawLine is accelerated */
+	GPU_ACCEL_FILLTRIANGLE		= 0x00000008,	/**< reserved */
+	GPU_ACCEL_BLIT				= 0x00010000,	/**< DDI_GPU_Blit is accelerated */
+	GPU_ACCEL_STRETCHBLIT		= 0x00020000,	/**< DDI_GPU_StretchBlit is accelerated */
+	GPU_ACCEL_TEXTRIANGLES		= 0x00040000,	/**< reserved */
+	GPU_ACCEL_TRAPEZOIDBLIT 	= 0x00080000,	/**< DDI_GPU_TrapezoidBlit is accelerated */
+	GPU_ACCEL_DECODEIMAGE		= 0x00100000,	/**< DDI_GPU_DecodeImage is accelerated */
+	GPU_ACCEL_DRAWSTRING		= 0x01000000,	/**< reserved */
+	GPU_ACCEL_FLIP				= 0x02000000, 	/**< Flip operation is supported */
+	GPU_ACCEL_ALL				= 0x031F000F,  	/**< All functions */
+	GPU_ACCEL_ALL_DRAW			= 0x0000000F,	/**< All draw functions */
+	GPU_ACCEL_ALL_BLIT			= 0x011F0000,	/**< All blit functions */
+} GPU_SUPPORTED_FUNC_MASK_T;
+
+
+/** 
+ * @brief This structure describes surface pool.
+ */
+typedef struct {
+	UINT32	physicalAddr;		/**< physical address of surface pool base */
+	UINT32	virtualAddr;		/**< virtual address of surface pool base */
+	UINT32	startOffset;		/**< the end of allocated layers (surface pool start with zero offset.) */
+	//FIXME: need to commit!
+	UINT32	size;				/**< size of surface pool (in bytes). It is not from startOffset but zero offset which means base point of surface pool. */
+	UINT16	byteOffsetAlign;	/**< bytes alignment constraint for the offset value of each surface allocation */
+	UINT16	bytePitchAlign;		/**< bytes alignment constraint for the surface's pitch value */
+} GPU_SURFACE_POOL_INFO_T;
+
+
+/**
+ * @brief This enumeration describes the supported pixel formats. 
+ */
+typedef enum 
+{
+	GPU_PIXEL_FORMAT_ARGB = 0,	/**< 32 bit ARGB (4 byte, alpha 8\@24, red 8\@16, green 8\@8, blue 8\@0) */
+	GPU_PIXEL_FORMAT_LUT8, 		/**< 8 bit LUT (8 bit color and alpha lookup from palette) */
+	GPU_PIXEL_FORMAT_ARGB1555, 	/**< 16 bit ARGB (2 byte, alpha 1\@15, red 5\@10, green 5\@5, blue 5\@0) */
+	GPU_PIXEL_FORMAT_RGB16, 	/**< 16 bit RGB (2 byte, red 5\@11, green 6\@5, blue 5\@0) */
+	GPU_PIXEL_FORMAT_ARGB4444, 	/**< 16 bit ARGB (2 byte, alpha 4\@12, red 4\@8, green 4\@4, blue 4\@0) */
+	GPU_PIXEL_FORMAT_A8, 		/**< 8 bit A (1 byte, alpha 8\@0) */
+	GPU_PIXEL_FORMAT_MAX		/**< Maximum number of GPU_PIXEL_FORMAT_T */
+} GPU_PIXEL_FORMAT_T;
+
+
+/**
+ * @brief This enumeration describes a information about image format.
+ */
+typedef enum {
+	GPU_IMAGE_FORMAT_JPEG		=0x0,
+	GPU_IMAGE_FORMAT_PNG,
+	GPU_IMAGE_FORMAT_GIF,
+	GPU_IMAGE_FORMAT_BMP,
+	GPU_IMAGE_FORMAT_BUFFER,
+	GPU_IMAGE_FORMAT_MAX,
+} GPU_IMAGE_FORMAT_T;
+
+
+/**
+ * @brief This structure describes a rectangle specified by a point and a dimension.
+ */
+typedef struct
+{
+	UINT16	x;	/**< x cordinate of its top-letf point */
+	UINT16	y;	/**< y cordinate of its top-left point */
+	UINT16	w;	/**< width of it */
+	UINT16	h;	/**< height of it */
+} GPU_RECT_T;
+
+
+/**
+ * @brief This structure describes a line specified by two points.
+ */
+typedef struct
+{
+	UINT16	x1;	/**< x cordinate of its top-letf point1 */
+	UINT16	y1;	/**< y cordinate of its top-left point1 */
+	UINT16	x2;	/**< x cordinate of its top-letf point2 */
+	UINT16	y2;	/**< y cordinate of its top-left point2 */
+} GPU_LINE_T;
+
+
+/**
+ * @brief This structure describes the palette information of the surface.
+ */
+typedef struct
+{
+	UINT32	*pPalette;	/**< point to the palette arry */
+	UINT32	length;		/**< size of palette (max: 256) */
+} GPU_PALETTE_INFO_T;
+
+
+/** 
+ * @brief This structure describes a surface specified by video memory offset, pitch and bpp.
+ */
+typedef struct
+{
+	UINT32				offset;			/**< bytes offset from the start of video memory */
+	UINT16				pitch;			/**< pitch: length of horizontal line */
+	UINT16				bpp;			/**< bits per pixel */
+	UINT16				width;			/**< width of surface */
+	UINT16				height;			/**< height of surface */
+	GPU_PIXEL_FORMAT_T	pixelFormat;	/**< pixel format of surface */
+	GPU_PALETTE_INFO_T	paletteInfo;	/**< palette information, this field is used when the surface's pixel format is based on indexed color. */
+	SINT32				id;				/**< surface identifier */
+	UINT32				property;		/**< reserved for future use */
+} GPU_SURFACE_INFO_T;
+
+
+/**
+ * @brief This structure describes screen resolution.
+ */
+typedef struct {
+	UINT16				width;			/**< width of screen */
+	UINT16				height; 		/**< height of screen */
+} GPU_SCREEN_RESOLUTION_T;
+
+
+/**
+ * @brief This structure describes configuration of layer for initializing GPU device.
+ */
+typedef struct {
+	UINT8 bUseDoubleBuffer;		/**< whether the double buffer should be allocated or not */
+	UINT8 bUseCreatedSurface;		/**< whether use createdSurfaceInfo or not. If TRUE, then layer is registered by using createdSurfaceInfo[2]. If FALSE, then layer is created newly by using creatingLayerInfo and createdSurfaceInfo[2] is not used. */
+	union
+	{
+		GPU_SURFACE_INFO_T	createdSurfaceInfo[2];	/**< information of created surface including backbuffer or frontbuffer */
+		struct {
+			UINT16				width;			/**< width of layer to be created */
+			UINT16				height; 		/**< height of layer to be created */
+			UINT32				property;		/**< property of layer to be created */
+			GPU_PIXEL_FORMAT_T	pixelFormat;	/**< pixelFormat of layer to be created */
+		} creatingLayerInfo; /**< information of layer to be created */
+	} layerInfo;
+} GPU_LAYER_CONFIG_T;
+
+
+/** 
+ * @brief This structure describes layer.
+ */
+typedef struct
+{
+	UINT8				bUseDoubleBuffer;	/**< If this value is 1, then double-buffering is used. If zero, then single-buffering is used. */
+	UINT8				doubleBufferIndex;	/**< Index number of buffer to draw. When double-buffering is used, this value indicates the index number of backbuffer otherwise, frontbuffer. */
+	GPU_SURFACE_INFO_T	surfaceInfo[2];		/**< surface information of frontbuffer and backbuffer. For example, if bUseDoubleBuffer is TRUE, you can access to the surface of backbuffer via surfaceInfo[doubleBufferIndex]. */
+	UINT16				opacity;			/**< opacity (zero means full transparency) */
+	GPU_RECT_T			region;				/**< viewable region of the layer */
+	UINT8				zOrder;				/**< z-order between layers, i.e., z axis position of a layer. Layer on the level zero is the bottom layer. */
+	UINT32				property;			/**< reserved for future use */
+} GPU_LAYER_REGION_INFO_T;
+
+
+/**
+ * @brief This enumeration describes the flags controlling blitting commands.
+ */
+typedef enum
+{
+	GPU_BLIT_NOFX					= 0x00000000, /**< uses none of the effects */
+	GPU_BLIT_BLEND_ALPHACHANNEL		= 0x00000001, /**< enables blending and uses
+													  alphachannel from source */
+	GPU_BLIT_BLEND_COLORALPHA		= 0x00000002, /**< enables blending and uses
+													  alpha value from color */
+	GPU_BLIT_COLORIZE				= 0x00000004, /**< modulates source color with
+													  the color's r/g/b values */
+	GPU_BLIT_SRC_COLORKEY			= 0x00000008, /**< don't blit pixels matching the source color key */
+	GPU_BLIT_DST_COLORKEY			= 0x00000010, /**< write to destination only if the destination pixel
+													  matches the destination color key */
+	GPU_BLIT_SRC_PREMULTIPLY		= 0x00000020, /**< modulates the source color with the (modulated)
+													  source alpha */
+	GPU_BLIT_DST_PREMULTIPLY		= 0x00000040, /**< modulates the dest. color with the dest. alpha */
+	GPU_BLIT_DEMULTIPLY				= 0x00000080, /**< divides the color by the alpha before writing the
+													  data to the destination */
+	GPU_BLIT_DEINTERLACE			= 0x00000100, /**< deinterlaces the source during blitting by reading
+													  only one field (every second line of full
+													  image) scaling it vertically by factor two */
+	GPU_BLIT_SRC_PREMULTCOLOR		= 0x00000200, /**< modulates the source color with the color alpha */
+	GPU_BLIT_XOR					= 0x00000400, /**< bitwise xor the destination pixels with the
+													 source pixels after premultiplication */
+	GPU_BLIT_INDEX_TRANSLATION		= 0x00000800, /**< do fast indexed to indexed translation,
+													 this flag is mutual exclusive with all others */
+	GPU_BLIT_ROTATE90				= 0x00001000, /**< rotate the image by 90 degree clockwise */
+	GPU_BLIT_ROTATE180				= 0x00002000, /**< rotate the image by 180 degree clockwise */
+	GPU_BLIT_ROTATE270				= 0x00004000, /**< rotate the image by 270 degree clockwise */
+	GPU_BLIT_COLORKEY_PROTECT		= 0x00010000, /**< make sure written pixels don't match color key (internal only ATM) */
+	GPU_BLIT_SRC_MASK_ALPHA			= 0x00100000, /**< modulate source alpha channel with alpha channel from source mask */
+	GPU_BLIT_SRC_MASK_COLOR			= 0x00200000, /**< modulate source color channels with color channels from source mask */
+
+	GPU_BLIT_VERTICAL_MIRROR		= 0x00400000,  /**< flip vertically (x positon is not changed)*/
+	GPU_BLIT_HORIZONTAL_MIRROR		= 0x00800000,  /**< flip horizontally (y positon is not changed)*/
+
+	GPU_BLIT_BLEND_ALPHACHANNEL_BCM				= 0x01000000, /**< BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | DST_PREUMLTCOLOR */
+	GPU_BLIT_BLEND_ALPHACHANNEL_COLORALPHA_BCM	= 0x02000000, /**< BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | BLEND_COLORALPHA | DST_PREUMLTCOLOR */
+	GPU_BLIT_BLEND_ALPHACHANNEL_COLORIZE_BCM	= 0x04000000, /**< BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | COLORIZE | DST_PREUMLTCOLOR */
+
+	GPU_BLIT_MAX  /**< the maximum value */
+
+} GPU_BLIT_FLAGS_T;
+
+
+/**
+ * @brief This enumeration describes the flags controlling drawing commands.
+ */
+typedef enum
+{
+	GPU_DRAW_NOFX					= 0x00000000, /**< uses none of the effects */
+	GPU_DRAW_BLEND					= 0x00000001, /**< uses alpha from color */
+	GPU_DRAW_DST_COLORKEY			= 0x00000002, /**< write to destination only if the destination pixel matches the destination color key */
+	GPU_DRAW_SRC_PREMULTIPLY		= 0x00000004, /**< muliplies the color's rgb channels by the alpha channel before drawing */
+	GPU_DRAW_DST_PREMULTIPLY		= 0x00000008, /**< modulates the dest. color with the dest. alpha */
+	GPU_DRAW_DEMULTIPLY				= 0x00000010, /**< divides the color by the alpha before writing the data to the destination */
+	GPU_DRAW_XOR					= 0x00000020, /**< bitwise xor the destination pixels with the specified color after premultiplication */
+	GPU_DRAW_MAX  /**< the maximum value */
+} GPU_DRAW_FLAGS_T;
+
+
+/**
+ * @brief This enumeration describes the blend functions to use for source and destination blending.
+ */
+typedef enum
+{
+	GPU_BLEND_UNKNOWN			= 0,  /**< Uknown blending function */
+	GPU_BLEND_ZERO				= 1,  /**< zero or, 0 */
+	GPU_BLEND_ONE				= 2,  /**< 1 */
+	GPU_BLEND_SRCCOLOR			= 3,  /**< source color */
+	GPU_BLEND_INVSRCCOLOR		= 4,  /**< inverse source alpha */
+	GPU_BLEND_SRCALPHA			= 5,  /**< source alpha */
+	GPU_BLEND_INVSRCALPHA		= 6,  /**< inverse source alpha (1-Sa)*/
+	GPU_BLEND_DESTALPHA			= 7,  /**< destination alpha */
+	GPU_BLEND_INVDESTALPHA		= 8,  /**< inverse destination lapha (1-Da)*/
+	GPU_BLEND_DESTCOLOR			= 9,  /**< destination color */
+	GPU_BLEND_INVDESTCOLOR		= 10, /**< inverse destination color */
+	GPU_BLEND_SRCALPHASAT		= 11, /**< source alpha saturation */
+	GPU_BLEND_MAX  /**< the maximum value */
+} GPU_BLEND_FUNCTION_T;
+
+
+/**
+ * @brief This enumeration describes the layer region flags for layer setting.
+ */
+typedef enum 
+{
+	GPU_LAYER_CONFIG_NONE		= 0x00000000,	/**< none */
+	GPU_LAYER_CONFIG_WIDTH		= 0x00000001,	/**< width (in pixels) of viewable region */
+	GPU_LAYER_CONFIG_HEIGHT		= 0x00000002,	/**< height (in pixels) of viewable region */
+	GPU_LAYER_CONFIG_OPACITY	= 0x00001000,	/**< layer opacity (0x00: invisible(layer-off), 0x01~0xfe: transparent layer, 0xff: fully opaque.) */
+	GPU_LAYER_CONFIG_ZORDER		= 0x00002000,	/**< z-order (or layer level) of layer */
+	GPU_LAYER_CONFIG_PROPERTY	= 0x00004000,	/**< property of layer */
+	GPU_LAYER_CONFIG_FORMAT 	= 0x00008000,	/**< layer pixel format */
+	GPU_LAYER_CONFIG_ALL		= 0x0000F003	/**< all */ 
+} GPU_LAYER_CONFIG_FLAGS_T;
+
+
+/**
+ * @brief This enumeration describes Flags controlling surface masks set.
+ */
+typedef enum {
+	GPU_SURFACE_MASK_NONE      = 0x00000000,  /**< none of these. */
+	GPU_SURFACE_MASK_STENCIL   = 0x00000001,  /**< Take <b>x</b> and <b>y</b> as fixed start coordinates in the mask. */
+	GPU_SURFACE_MASK_ALL       = 0x00000001,  /**< all of these. */
+} GPU_SURFACE_MASK_FLAGS_T;
+
+/**
+ * @brief This enumeration describes supported image format for HW decoding.
+ */
+typedef enum {
+	GPU_IMAGE_FORMAT_NONE_SUPPORTED		= 0x00000000,
+	GPU_IMAGE_FORMAT_JPEG_SUPPORTED		= 0x00000001,
+	GPU_IMAGE_FORMAT_PNG_SUPPORTED		= 0x00000002,
+	GPU_IMAGE_FORMAT_GIF_SUPPORTED		= 0x00000004,
+	GPU_IMAGE_FORMAT_BMP_SUPPORTED		= 0x00000008,
+	GPU_IMAGE_FORMAT_BUFFER_SUPPORTED	= 0x00000010,
+	GPU_IMAGE_FORMAT_ALL				= 0x0000001F,
+} GPU_SUPPORTED_IMAGE_FORMAT_FLAGS_T;
+
+
+/**
+ * @brief This structure describes the 2D graphic capability of device.
+ */
+typedef struct {
+	UINT8						bAllocatorSupported;	/**< whether the allocator is supported, or not (if supported, then this value is TRUE otherwise FALSE.) */
+	GPU_BLIT_FLAGS_T			blitFlags;				/**< supported blit flags */
+	GPU_DRAW_FLAGS_T			drawFlags;				/**< supported draw flags */
+	GPU_SUPPORTED_FUNC_MASK_T	supportedFunctions;		/**< supported functions */
+	UINT8						maxNumOfLayers;			/**< the maximum number of supported layers */
+	UINT32						virtualAddrOfBase;		/**< virtual address of videomemory start (or base of offset) */
+	GPU_SUPPORTED_IMAGE_FORMAT_FLAGS_T		supportedImageFormat; /**< Image format that can be decoded by HW decoder */
+	UINT32		hwDecodeMinLimitWidth;		/**< Minimum limitation of supported width for HW decoding (Zero means no limitation) */
+	UINT32		hwDecodeMinLimitHeight;		/**< Minimum limitation of supported height for HW decoding (Zero means no limitation) */
+	UINT16		hwDecodeMaxLimitWidth;		/**< Maximum limitation of supported width for HW decoding (Zero means no limitation) */
+	UINT16		hwDecodeMaxLimitHeight;		/**< Maximum limitation of supported height for HW decoding (Zero means no limitation) */
+	UINT32		hwDecodeMaxLimitArea;		/**< Maximum limitation of supported area (width*height) for HW decoding (Zero means no limitation). This value may mean the size of allocated surface. */
+	UINT32		maxScaleUpFactor;		/**< maximum factor on scaling up (stretchblit).  */
+	UINT32		minScaleDownFactor; 	/**< minimum factor on scaling down (stretchblit) */
+	UINT32		swBlitArea;				/**< if width*height < swBlitArea then, SW blit operation may be faster. */
+	UINT16		hwBlitLimitWidth;		/**< Limitation of supported width for HW blit (Zero means no limitation) */
+	UINT16		hwBlitLimitHeight;		/**< Limitation of supported height for HW blit (Zero means no limitation) */
+	UINT32		hwBlitLimitArea;		/**< Limitation of supported area (width*height) for HW blit (Zero means no limitation) */
+} GPU_DEVICE_CAPABILITY_INFO_T;
+
+
+/** 
+ * @brief This structure describes source mask.
+ */
+typedef struct
+{
+	UINT32						offset;	/**< bytes offset from the start of video memory */
+	UINT16						x;		/**< x */
+	UINT16						y;		/**< y */
+	GPU_SURFACE_MASK_FLAGS_T	flags;	/**< STENCIL or not*/
+} GPU_SOURCE_MASK_T;
+
+
+/** 
+ * @brief This structure describes settings for draw operation.
+ */
+typedef struct
+{
+	GPU_BLEND_FUNCTION_T	srcBlend;		/**< source blend function */
+	GPU_BLEND_FUNCTION_T	dstBlend;		/**< destination blend function */
+	UINT32					dstColorkey;	/**< destination colorkey */
+} GPU_DRAW_SETTINGS_T;
+
+
+/** 
+ * @brief This structure describes settings for blit operation.
+ */
+typedef struct
+{
+	GPU_BLEND_FUNCTION_T	srcBlend;		/**< source blend function */
+	GPU_BLEND_FUNCTION_T	dstBlend;		/**< destination blend function */
+	UINT32					alpha;			/**< global alpha value */
+	UINT32					color;			/**< global color value */
+	UINT32					srcColorkey;	/**< source colorkey */
+	UINT32					dstColorkey;	/**< destination colorkey */
+	GPU_SOURCE_MASK_T		srcMask;		/**< source mask information*/
+} GPU_BLIT_SETTINGS_T;
+
+
+/**
+ * @brief This structure describes the trapezoid rendering.
+ */
+typedef struct
+{
+	GPU_RECT_T	srcRect;			/**< source rectangular which represents source image */
+	UINT8		alphaConst;			/**< constant alpha blending (range: 0~255) */
+	UINT8		bAntiAliasing;		/**< antialising option for trapezoid edge smoothing (0:off, 1:on) */
+	UINT8		trapDir;			/**< Trapezoid direction mode (0: vertical trapezoid rendering mode, 1: horizontal rendering mode */
+	UINT8		srcRectRotateDir;	/**< Source rectangular clockwise rotation (0: 0 degree, 1: 90, 2: 180 degree, 3: 270 degree) */
+	UINT8		dstTrapRotateDir;	/**< Destination trapezoid clockwise rotation (0: 0 degree, 1: 90 degree, 2: 180 degree, 3: 270 degree) */
+	UINT16		dstTrapEdge0Pos;	/**< y-coor for vertical trapezoid, x-coor for horizontal trapezoid */
+	UINT16		dstTrapEdge0St;		/**< x-coor for vertical trapezoid, y-coor for horizontal trapezoid */
+	UINT16		dstTrapEdge0End;	/**< x-coor for vertical trapezoid, y-coor for horizontal trapezoid */
+	UINT16		dstTrapEdge1St;		/**< x-coor for vertical trapezoid, y-coor for horizontal trapezoid */
+	UINT16		dstTrapEdge1End;	/**< x-coor for vertical trapezoid, y-coor for horizontal trapezoid */
+	UINT16		dstTrapDistance;	/**< the distance between destination parallel edge0 and parallel edge1 */
+} GPU_TRAPEZOID_T;
+
+
+/**
+ * @brief This structure describes information about image.
+ */
+typedef struct
+{
+	GPU_IMAGE_FORMAT_T 	imageFormat;
+	GPU_RECT_T			rect;
+	UINT32				imageLength;
+	GPU_PIXEL_FORMAT_T	pixelFormat;
+	UINT8				bImageFromBuffer;
+	CHAR				*imagePath;
+	UINT32				*imagePtr;
+} GPU_IMAGE_INFO_T;
+
+/**
+ * @brief This enumeration describes the flags controlling decoded image.
+ */
+typedef enum
+{
+	GPU_DECODEIMAGE_NOFX               = 0x00000000, /**< uses none of the effects */
+	GPU_DECODEIMAGE_PREMULTIPLY        = 0x00000001, /**< modulates the image color with the image alpha */
+	GPU_DECODEIMAGE_ROTATE90           = 0x00000010, /**< rotate the image by 90 degree clockwise */
+	GPU_DECODEIMAGE_ROTATE180          = 0x00000020, /**< rotate the image by 180 degree clockwise */
+	GPU_DECODEIMAGE_ROTATE270          = 0x00000040, /**< rotate the image by 270 degree clockwise */
+	GPU_DECODEIMAGE_VERTICAL_MIRROR    = 0x00000100, /**< flip vertically (x positon is not changed)*/
+	GPU_DECODEIMAGE_HORIZONTAL_MIRROR  = 0x00000200, /**< flip horizontally (y positon is not changed)*/
+	GPU_DECODEIMAGE_ALL                = 0x000003b1  /**< all */
+} GPU_DECODEIMAGE_FLAGS_T;
+
+
+/**
+ * @brief This enumeration describes property of a surface (or layer).
+ */
+typedef enum {
+	GPU_PROPERTY_NONE				= 0x00000000,
+	GPU_PROPERTY_LAYER_FOR_DIRECTFB	= 0x00000001,
+	GPU_PROPERTY_LAYER_FOR_UI		= 0x00000002,
+
+	GPU_PROPERTY_ALL				= 0xffffffff
+} GPU_PROPERTY_T;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __DDI_GPU_DATA_H__ */
diff -ruNb DirectFB-1.7.7_orig/dtv_lib/ddi_gpu.h DirectFB-1.7.7/dtv_lib/ddi_gpu.h
--- DirectFB-1.7.7_orig/dtv_lib/ddi_gpu.h	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7/dtv_lib/ddi_gpu.h	2016-07-03 21:27:43.239959443 +0200
@@ -0,0 +1,94 @@
+#ifndef __DDI_GPU_H__
+#define __DDI_GPU_H___
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ddi_gpu_data.h"
+
+#define DDI_GPU_PRINTF(x...) 
+
+#include <dlfcn.h>
+#include <pthread.h>
+
+static DTV_STATUS_T (*RPC_OpenDDI_GPU)(SINT32 sock) = NULL;
+static void (*RPC_CloseDDI_GPU)() = NULL;
+static DTV_STATUS_T (*DDI_GPU_Initialize)(UINT32 width, UINT32 height, GPU_PIXEL_FORMAT_T pixelFormat, GPU_SCREEN_RESOLUTION_T *pScreenResolution) = NULL;
+static DTV_STATUS_T (*DDI_GPU_GetDeviceCapability)(GPU_DEVICE_CAPABILITY_INFO_T *pDeviceCapabilityInfo) = NULL;
+static DTV_STATUS_T (*DDI_GPU_InitSurfacePool)(UINT32 surfacePoolSize, UINT16 surfacePoolAlignment, GPU_SURFACE_POOL_INFO_T *pSurfacePoolInfo) = NULL;
+static DTV_STATUS_T (*DDI_GPU_InitLayer)(UINT8 layerId, GPU_LAYER_CONFIG_T layerConfig) = NULL;
+static DTV_STATUS_T (*DDI_GPU_Finalize)(void) = NULL;
+static DTV_STATUS_T (*DDI_GPU_GetLayerRegionInfo)(SINT32 layer, GPU_LAYER_REGION_INFO_T *pLayerRegionInfo) = NULL;
+static DTV_STATUS_T (*DDI_GPU_SetLayerRegion)(SINT32 layer, GPU_LAYER_CONFIG_FLAGS_T regionFlags, GPU_RECT_T viewRect, GPU_RECT_T dispRect, UINT32 regionAlpha, UINT8 zOrder, UINT32 property, GPU_PIXEL_FORMAT_T pixelFormat) = NULL;
+static DTV_STATUS_T (*DDI_GPU_FlipLayerRegion)(SINT32 layer, UINT32 bufferOffset) = NULL;
+static DTV_STATUS_T (*DDI_GPU_UpdateLayerRegion)(SINT32 layer, GPU_RECT_T updateRect, UINT32 bufferOffset) = NULL;
+static DTV_STATUS_T (*DDI_GPU_IndicateLayerUpdate)(SINT32 layer, GPU_RECT_T updateRect, UINT32 bufferOffset) = NULL;
+static DTV_STATUS_T (*DDI_GPU_AllocSurface)(UINT16 width, UINT16 height, GPU_PIXEL_FORMAT_T pixelFormat, GPU_SURFACE_INFO_T *pSurfaceInfo) = NULL;
+static DTV_STATUS_T (*DDI_GPU_SetSurfacePalette)(GPU_SURFACE_INFO_T surface, UINT32 palette[256], SINT32 paletteLength) = NULL;
+static DTV_STATUS_T (*DDI_GPU_DeallocSurface)(GPU_SURFACE_INFO_T surface) = NULL;
+static DTV_STATUS_T (*DDI_GPU_Blit)(GPU_SURFACE_INFO_T srcSurface, GPU_RECT_T srcRect, GPU_SURFACE_INFO_T dstSurface, UINT16 dx, UINT16 dy, GPU_BLIT_FLAGS_T blitFlags, GPU_BLIT_SETTINGS_T blitSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_StretchBlit)(GPU_SURFACE_INFO_T srcSurface, GPU_RECT_T srcRect, GPU_SURFACE_INFO_T dstSurface, GPU_RECT_T dstRect, GPU_BLIT_FLAGS_T blitFlags, GPU_BLIT_SETTINGS_T blitSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_FillRectangle)(GPU_SURFACE_INFO_T dstSurface, GPU_RECT_T dstRect, UINT32 color, GPU_DRAW_FLAGS_T drawFlags, GPU_DRAW_SETTINGS_T drawSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_DrawRectangle)(GPU_SURFACE_INFO_T dstSurface, GPU_RECT_T dstRect, UINT32 color, GPU_DRAW_FLAGS_T drawFlags, GPU_DRAW_SETTINGS_T drawSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_DrawLine)(GPU_SURFACE_INFO_T dstSurface, GPU_LINE_T dstLine, UINT32 color, GPU_DRAW_FLAGS_T drawFlags, GPU_DRAW_SETTINGS_T drawSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_SyncGraphic)(void) = NULL;
+static DTV_STATUS_T (*DDI_GPU_TrapezoidBlit)(GPU_SURFACE_INFO_T srcSurface, GPU_SURFACE_INFO_T dstSurface, GPU_TRAPEZOID_T trapezoidSet, GPU_BLIT_FLAGS_T blitFlags, GPU_BLIT_SETTINGS_T blitSettings) = NULL;
+static DTV_STATUS_T (*DDI_GPU_DecodeImage)(GPU_IMAGE_INFO_T imageInfo, GPU_SURFACE_INFO_T dstSurface, GPU_DECODEIMAGE_FLAGS_T decodeFlags) = NULL;
+
+static void* gRPCHandle;
+
+static inline void assign_symbol_DDI_GPU_FUNCS(pthread_mutex_t *pMutex)
+{
+	if(DDI_GPU_Initialize == NULL)
+	{
+		/* dlclose(gRPCHandle); */
+		if(pMutex){
+			pthread_mutex_lock(pMutex);
+		}
+		gRPCHandle = dlopen("librpc4dtv.so.1", RTLD_NOW);
+		if(pMutex){
+			pthread_mutex_unlock(pMutex);
+		}
+		if(!gRPCHandle)
+		{
+			DDI_GPU_PRINTF("Error: dlopen... Missing library-librpc4dtv.so..\n");
+		} else {
+
+			if(pMutex){
+				pthread_mutex_lock(pMutex);
+			}
+			*(void **) (&RPC_OpenDDI_GPU) = dlsym(gRPCHandle, "RPC_OpenDDI_GPU");
+			*(void **) (&RPC_CloseDDI_GPU) = dlsym(gRPCHandle, "PRC_CloseDDI_GPU");
+			*(void **) (&DDI_GPU_Initialize) = dlsym(gRPCHandle, "DDI_GPU_Initialize");
+			*(void **) (&DDI_GPU_GetDeviceCapability) = dlsym(gRPCHandle, "DDI_GPU_GetDeviceCapability");
+			*(void **) (&DDI_GPU_InitSurfacePool) = dlsym(gRPCHandle, "DDI_GPU_InitSurfacePool");
+			*(void **) (&DDI_GPU_InitLayer) = dlsym(gRPCHandle, "DDI_GPU_InitLayer");
+			*(void **) (&DDI_GPU_Finalize) = dlsym(gRPCHandle, "DDI_GPU_Finalize");
+			*(void **) (&DDI_GPU_GetLayerRegionInfo) = dlsym(gRPCHandle, "DDI_GPU_GetLayerRegionInfo");
+			*(void **) (&DDI_GPU_SetLayerRegion) = dlsym(gRPCHandle, "DDI_GPU_SetLayerRegion");
+			*(void **) (&DDI_GPU_FlipLayerRegion) = dlsym(gRPCHandle, "DDI_GPU_FlipLayerRegion");
+			*(void **) (&DDI_GPU_UpdateLayerRegion) = dlsym(gRPCHandle, "DDI_GPU_UpdateLayerRegion"); 
+			*(void **) (&DDI_GPU_IndicateLayerUpdate) = dlsym(gRPCHandle, "DDI_GPU_IndicateLayerUpdate"); 
+			*(void **) (&DDI_GPU_AllocSurface) = dlsym(gRPCHandle, "DDI_GPU_AllocSurface");
+			*(void **) (&DDI_GPU_SetSurfacePalette) = dlsym(gRPCHandle, "DDI_GPU_SetSurfacePalette");
+			*(void **) (&DDI_GPU_DeallocSurface) = dlsym(gRPCHandle, "DDI_GPU_DeallocSurface");
+			*(void **) (&DDI_GPU_Blit) = dlsym(gRPCHandle, "DDI_GPU_Blit");
+			*(void **) (&DDI_GPU_StretchBlit) = dlsym(gRPCHandle, "DDI_GPU_StretchBlit");
+			*(void **) (&DDI_GPU_FillRectangle) = dlsym(gRPCHandle, "DDI_GPU_FillRectangle");
+			*(void **) (&DDI_GPU_DrawRectangle) = dlsym(gRPCHandle, "DDI_GPU_DrawRectangle");
+			*(void **) (&DDI_GPU_DrawLine) = dlsym(gRPCHandle, "DDI_GPU_DrawLine");
+			*(void **) (&DDI_GPU_SyncGraphic) = dlsym(gRPCHandle, "DDI_GPU_SyncGraphic");
+			*(void **) (&DDI_GPU_TrapezoidBlit) = dlsym(gRPCHandle, "DDI_GPU_TrapezoidBlit");
+			*(void **) (&DDI_GPU_DecodeImage) = dlsym(gRPCHandle, "DDI_GPU_DecodeImage");
+			
+			if(pMutex){
+				pthread_mutex_unlock(pMutex);
+			}
+		}
+	}
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __DDI_GPU_H__ */
diff -ruNb DirectFB-1.7.7_orig/dtv_lib/README DirectFB-1.7.7/dtv_lib/README
--- DirectFB-1.7.7_orig/dtv_lib/README	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7/dtv_lib/README	2011-07-26 10:30:13.000000000 +0200
@@ -0,0 +1,2 @@
+How to build:
+Copy ddi_gpu*.h to the directory where header files exist.
diff -ruNb DirectFB-1.7.7_orig/include/directfb.h DirectFB-1.7.7/include/directfb.h
--- DirectFB-1.7.7_orig/include/directfb.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/include/directfb.h	2016-07-03 14:26:09.878265618 +0200
@@ -764,6 +764,12 @@
                                                     see also IDirectFBSurface::SetSourceMask() */
      DSBLIT_SRC_MASK_COLOR         = 0x00200000, /* modulate source color channels with color channels from source mask,
                                                     see also IDirectFBSurface::SetSourceMask() */
+     DSBLIT_VERTICAL_MIRROR    = 0x00400000, /* flip vertically (x position is not changed)*/
+     DSBLIT_HORIZONTAL_MIRROR  = 0x00800000, /* flip hozontally (y position is not changed)*/
+
+     DSBLIT_BLEND_ALPHACHANNEL_BCM              = 0x01000000, /* BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | DST_PREUMLTCOLOR */
+     DSBLIT_BLEND_ALPHACHANNEL_COLORALPHA_BCM   = 0x02000000, /* BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | BLEND_COLORALPHA | DST_PREUMLTCOLOR */
+     DSBLIT_BLEND_ALPHACHANNEL_COLORIZE_BCM     = 0x04000000, /* BCM specific mechanism similar to SRC_PREMULTCOLOR | BLEND_ALPHACHANNEL | COLORIZE | DST_PREUMLTCOLOR */
      DSBLIT_FLIP_HORIZONTAL        = 0x01000000, /* flip the image horizontally */
      DSBLIT_FLIP_VERTICAL          = 0x02000000, /* flip the image vertically */
      DSBLIT_ROP                    = 0x04000000, /* use rop setting */
diff -ruNb DirectFB-1.7.7_orig/include/directfb_strings.h DirectFB-1.7.7/include/directfb_strings.h
--- DirectFB-1.7.7_orig/include/directfb_strings.h	2015-02-11 15:44:56.000000000 +0100
+++ DirectFB-1.7.7/include/directfb_strings.h	2016-07-03 14:27:00.868042644 +0200
@@ -175,6 +175,11 @@
      { DSBLIT_DST_COLORKEY_EXTENDED, "DST_COLORKEY_EXTENDED" }, \
      { DSBLIT_SRC_MASK_ALPHA, "SRC_MASK_ALPHA" }, \
      { DSBLIT_SRC_MASK_COLOR, "SRC_MASK_COLOR" }, \
+     { DSBLIT_VERTICAL_MIRROR, "VERTICAL_MIRROR" }, \
+     { DSBLIT_HORIZONTAL_MIRROR, "HORIZONTAL_MIRROR" }, \
+     { DSBLIT_BLEND_ALPHACHANNEL_BCM, "BLEND_ALPHACHANNEL_BCM" }, \
+     { DSBLIT_BLEND_ALPHACHANNEL_COLORALPHA_BCM, "BLEND_ALPHACHANNEL_COLORALPHA_BCM" }, \
+     { DSBLIT_BLEND_ALPHACHANNEL_COLORIZE_BCM, "BLEND_ALPHACHANNEL_COLORIZE_BCM" }, \
      { DSBLIT_FLIP_HORIZONTAL, "FLIP_HORIZONTAL" }, \
      { DSBLIT_FLIP_VERTICAL, "FLIP_VERTICAL" }, \
      { DSBLIT_ROP, "ROP" }, \
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_cif.c DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_cif.c
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_cif.c	1970-01-01 01:00:00.000000000 +0100
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_cif.c	2016-07-03 15:10:18.504193365 +0200
@@ -0,0 +1,454 @@
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <stdarg.h>
+
+#include <directfb.h>
+
+#include <display/idirectfbsurface.h>
+
+#include <media/idirectfbimageprovider.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/layers.h>
+#include <core/surface.h>
+
+#include <misc/gfx_util.h>
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <misc/util.h>
+
+#define D_IMG_PRINTF(x...)                                                           \
+     do {                                                                            \
+          if (direct_config->debug) printf( x );                 \
+     } while (0)
+
+#pragma pack (push,1)
+
+#define CIF_FILE_ID "HDDVDCIF"
+
+#define ENC_TY_CVF 0x1
+#define ENC_TY_CDF 0x2
+
+typedef struct {
+	char file_id[8];         // must be 'HDDVDCIF'
+	unsigned char vern_reserved;
+	unsigned char vern_bookpart; //must be 0x10
+	unsigned char enc_ty;    // must be 1 for CVF and 2 for CDF
+	unsigned short width;    // max:1920
+	unsigned short height;   // max:1080
+	unsigned char reserved[49];
+} cif_header_t;
+
+#pragma pack (pop)
+
+#define SWAP_SHORT(w) w=((w<<8) | (w>>8))
+
+static void swap_cif_header(cif_header_t* header)
+{
+	SWAP_SHORT(header->width);
+	SWAP_SHORT(header->height);
+}
+
+static DFBResult
+Probe( IDirectFBImageProvider_ProbeContext *ctx );
+
+static DFBResult
+Construct( IDirectFBImageProvider *thiz,
+          ... );
+
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, CIF )
+
+/*
+ * private data struct of IDirectFBImageProvider_CIF
+ */
+typedef struct {
+     int                  ref;      /* reference counter */
+
+     IDirectFBDataBuffer *buffer;
+
+} IDirectFBImageProvider_CIF_data;
+
+static DirectResult
+IDirectFBImageProvider_CIF_AddRef  ( IDirectFBImageProvider *thiz );
+
+static DirectResult
+IDirectFBImageProvider_CIF_Release ( IDirectFBImageProvider *thiz );
+
+static DFBResult
+IDirectFBImageProvider_CIF_RenderTo( IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *destination_rect );
+
+static DFBResult
+IDirectFBImageProvider_CIF_SetRenderCallback( IDirectFBImageProvider *thiz,
+                                              DIRenderCallback        callback,
+                                              void                   *context );
+
+static DFBResult
+IDirectFBImageProvider_CIF_GetSurfaceDescription( IDirectFBImageProvider *thiz,
+                                                  DFBSurfaceDescription  *dsc );
+
+static DFBResult
+IDirectFBImageProvider_CIF_GetImageDescription( IDirectFBImageProvider *thiz,
+                                                DFBImageDescription    *dsc );
+
+static DFBResult
+Probe( IDirectFBImageProvider_ProbeContext *ctx )
+{
+     cif_header_t* header=(cif_header_t*)ctx->header;
+
+     D_IMG_PRINTF( "Probe (CIF) ...\n");
+
+     if (memcmp (header->file_id, CIF_FILE_ID, sizeof(header->file_id)) != 0)
+     {
+          D_IMG_PRINTF( "    ==> NOT CIF format!\n");
+          return DFB_UNSUPPORTED;
+     }
+
+     if(header->vern_bookpart != 0x10)
+     {
+          D_IMG_PRINTF( "    ==> NOT CIF format!\n");
+          return DFB_UNSUPPORTED;
+     }
+
+     if(header->enc_ty != ENC_TY_CVF && header->enc_ty != ENC_TY_CDF)
+     {
+          D_IMG_PRINTF( "    ==> NOT CIF format!\n");
+          return DFB_UNSUPPORTED;
+     }
+
+     //passed all checks: this is a CIF file!
+     D_IMG_PRINTF( "    ==> CIF format!\n");
+     return DFB_OK;
+}
+
+static DFBResult
+Construct( IDirectFBImageProvider *thiz,
+          ... )
+{
+     IDirectFBDataBuffer *buffer;
+     va_list              tag;
+
+     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBImageProvider_CIF)
+
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     va_end( tag );
+
+     D_MAGIC_ASSERT( (IAny*) buffer, DirectInterface );
+
+     data->ref    = 1;
+     data->buffer = buffer;
+
+     buffer->AddRef( buffer );
+
+     thiz->AddRef                = IDirectFBImageProvider_CIF_AddRef;
+     thiz->Release               = IDirectFBImageProvider_CIF_Release;
+     thiz->RenderTo              = IDirectFBImageProvider_CIF_RenderTo;
+     thiz->SetRenderCallback     = IDirectFBImageProvider_CIF_SetRenderCallback;
+     thiz->GetImageDescription   = IDirectFBImageProvider_CIF_GetImageDescription;
+     thiz->GetSurfaceDescription = IDirectFBImageProvider_CIF_GetSurfaceDescription;
+
+     return DFB_OK;
+}
+
+static void
+IDirectFBImageProvider_CIF_Destruct( IDirectFBImageProvider *thiz )
+{
+     IDirectFBImageProvider_CIF_data *data =
+                                   (IDirectFBImageProvider_CIF_data*)thiz->priv;
+
+     data->buffer->Release( data->buffer );
+
+     DIRECT_DEALLOCATE_INTERFACE( thiz );
+}
+
+
+static DirectResult
+IDirectFBImageProvider_CIF_AddRef( IDirectFBImageProvider *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_CIF)
+
+     data->ref++;
+
+     return DFB_OK;
+}
+
+static DirectResult
+IDirectFBImageProvider_CIF_Release( IDirectFBImageProvider *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_CIF)
+
+     if (--data->ref == 0) {
+          IDirectFBImageProvider_CIF_Destruct( thiz );
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult
+DecodeCDF(void* surfdata, int pitch, int w, int h, IDirectFBDataBuffer* buffer)
+{
+	DFBResult result=DFB_OK;
+	unsigned int bytes_read;
+	int y;
+
+	//simply dump the file, line by line
+	for(y=0;y<h;y++)
+	{
+		result=buffer->GetData(buffer,w*sizeof(unsigned long),surfdata,&bytes_read);
+		if(result!=DFB_OK)
+		{
+			D_ERROR("failed (%s) reading data at line %d\n",DirectFBErrorString(result),y);
+			break;
+		}
+
+		surfdata=(unsigned long*)((unsigned char*)surfdata+pitch);
+	}
+
+	return result;
+}
+
+static DFBResult
+DecodeCVF(void* surfdata, int pitch, int w, int h, IDirectFBDataBuffer* buffer)
+{
+	DFBResult result=DFB_OK;
+	int l,p;
+	unsigned char* src=NULL;
+	unsigned int bytes_read;
+
+	//allocate temporary buffer, enough for one full line of Y.
+	src=malloc(w);
+	if(src==NULL)
+		result=DFB_NOSYSTEMMEMORY;
+
+    /* Pixel position is YCrYCb where Cb is LSB */
+
+	//Y PLANE
+	if(result==DFB_OK)
+	{
+ 		for(l=0;l<h;l++)
+ 		{
+ 			unsigned long* dst_line=(unsigned long*)((char*)surfdata + pitch*l);
+ 			unsigned char* src_line=src;
+
+ 			//read source line
+ 			result=buffer->GetData(buffer,w,src_line,&bytes_read);
+ 			if(result!=DFB_OK) break;
+
+ 			//write dest line
+ 			for(p=0;p<w/2;p++)
+ 			{
+ 				*dst_line++ = (*src_line)<<8 | (*(src_line+1))<<24;
+ 				src_line+=2;
+ 			}
+ 		}
+	}
+
+	//Cr PLANE
+	if(result==DFB_OK)
+	{
+ 		for(l=0;l<h/2;l++)
+ 		{
+ 			unsigned long* first_line=(unsigned long*)((char*)surfdata + pitch*l*2);
+ 			unsigned long* second_line=(unsigned long*)((char*)surfdata + pitch*(l*2+1));
+
+ 			unsigned char* src_line=src;
+
+ 			//read source line
+ 			result=buffer->GetData(buffer,w/2,src_line,&bytes_read);
+ 			if(result!=DFB_OK) break;
+
+ 			//write dest line
+ 			for(p=0;p<w/2;p++)
+ 			{
+ 				register int cr=(*src_line++)<<16;
+ 				*first_line++  |= cr;
+ 				*second_line++ |= cr;
+ 			}
+ 		}
+	}
+
+	//Cb PLANE
+	if(result==DFB_OK)
+	{
+		for(l=0;l<h/2;l++)
+ 		{
+ 			unsigned long* first_line=(unsigned long*)((char*)surfdata + pitch*l*2);
+ 			unsigned long* second_line=(unsigned long*)((char*)surfdata + pitch*(l*2+1));
+
+ 			unsigned char* src_line=src;
+
+ 			//read source line
+ 			result=buffer->GetData(buffer,w/2,src_line,&bytes_read);
+ 			if(result!=DFB_OK) break;
+
+ 			//write dest line
+ 			for(p=0;p<w/2;p++)
+ 			{
+ 				register int cb=*src_line++;
+ 				*first_line++  |= cb;
+ 				*second_line++ |= cb;
+ 			}
+ 		}
+	}
+
+	//free temporary buffer
+	if(src)
+		free(src);
+
+	return result;
+}
+
+
+static DFBResult
+IDirectFBImageProvider_CIF_RenderTo( IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect )
+{
+	DFBResult              result = DFB_OK;
+	DFBRectangle           rect = { 0, 0, 0, 0 };
+	DFBSurfacePixelFormat  format;
+	cif_header_t           header;
+	unsigned int           bytes_read;
+	void*                  surfdata = NULL;
+	int                    pitch = 0;
+
+	D_DEBUG("IDirectFBImageProvider_CIF_RenderTo\n");
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
+	DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_CIF)
+
+	if(dest_rect==NULL) {
+	    result = destination->GetSize( destination, &rect.w, &rect.h );
+	    if(result!=DFB_OK) return result;
+
+	    dest_rect=&rect;
+	}
+
+	result = destination->GetPixelFormat( destination, &format );
+	if(result!=DFB_OK) return result;
+
+	//read the header
+	result=data->buffer->GetData(data->buffer,sizeof(header),&header,&bytes_read);
+	if(result==DFB_OK)
+ 		if(bytes_read!=sizeof(header))
+ 			result=DFB_IO;
+
+	swap_cif_header(&header);
+
+	if((header.enc_ty == ENC_TY_CVF && format != DSPF_UYVY) || (header.enc_ty == ENC_TY_CDF && format != DSPF_ARGB))
+	{
+		D_ERROR("header.enc_ty = %d, format=%x\n", header.enc_ty, format);
+	    D_ERROR("destination surface has the wrong pixel format\n");
+	    return DFB_INVARG;
+	}
+
+ 	if(header.width != rect.w || header.height != rect.h)
+	{
+          D_ERROR("header.width=%d, header.height=%d, rect.w=%d, rect.h=%d\n", header.width, header.height, rect.w, rect.h);
+          D_ERROR("image file does not have the same size as the destination surface\n");
+          return DFB_INVARG;
+	}
+
+	//obtain a pointer to the surface data
+ 	if(result==DFB_OK)
+ 		result=destination->Lock(destination,DSLF_WRITE,&surfdata,&pitch);
+
+ 	//jump to the beginning of the dest_rect
+ 	if(result==DFB_OK)
+	 	surfdata=(unsigned char*)surfdata + dest_rect->y*pitch + dest_rect->x*sizeof(unsigned long);
+
+	if(result==DFB_OK) {
+    	switch(header.enc_ty)
+    	{
+    	case ENC_TY_CVF:
+    		result=DecodeCVF(surfdata,pitch,header.width,header.height,data->buffer);
+    		break;
+    	case ENC_TY_CDF:
+    		result=DecodeCDF(surfdata,pitch,header.width,header.height,data->buffer);
+    		break;
+    	default:
+    		D_ERROR("invalid enc_ty");
+    		result=DFB_INVARG;
+    		break;
+    	}
+	}
+
+	destination->Unlock(destination);
+
+     D_IMG_PRINTF("%s() return %d <---\n", __func__, result);
+	return result;
+}
+
+static DFBResult
+IDirectFBImageProvider_CIF_SetRenderCallback( IDirectFBImageProvider *thiz,
+                                              DIRenderCallback        callback,
+                                              void                   *context )
+{
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult
+IDirectFBImageProvider_CIF_GetSurfaceDescription( IDirectFBImageProvider *thiz,
+                                                  DFBSurfaceDescription  *dsc )
+{
+	DFBResult result=DFB_OK;
+	cif_header_t header;
+	unsigned int bytes_read=0;
+
+	DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_CIF)
+
+	result=data->buffer->PeekData(data->buffer,sizeof(header),0,&header,&bytes_read);
+	swap_cif_header(&header);
+
+	if(result==DFB_OK)
+	{
+		if(bytes_read != sizeof(header))
+			result=DFB_FAILURE;
+	}
+
+	if(result==DFB_OK)
+	{
+		dsc->flags       = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+		dsc->width       = header.width;
+		dsc->height      = header.height;
+
+		if(header.enc_ty == ENC_TY_CVF)
+			dsc->pixelformat = DSPF_UYVY; //actually, the file is in DSPF_YV12 but we don't support that format...
+		else if(header.enc_ty == ENC_TY_CDF)
+			dsc->pixelformat = DSPF_ARGB;
+		else
+			result=DFB_UNSUPPORTED;
+
+	}
+
+	return result;
+}
+
+static DFBResult
+IDirectFBImageProvider_CIF_GetImageDescription( IDirectFBImageProvider *thiz,
+                                                DFBImageDescription    *dsc )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_CIF)
+
+     if (!dsc)
+          return DFB_INVARG;
+
+     dsc->caps = DICAPS_NONE;
+
+     return DFB_OK;
+}
+
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_dfiff.c DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_dfiff.c
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_dfiff.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_dfiff.c	2016-07-03 13:50:07.659744322 +0200
@@ -62,6 +62,11 @@
 
 #include <dfiff.h>
 
+#define D_IMG_PRINTF(x...)                                                           \
+     do {                                                                            \
+          if (direct_config->debug) printf( x );                 \
+     } while (0)
+
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
 
@@ -111,6 +116,7 @@
      bool                   dfiff_premultiplied = false;
      bool                   dest_premultiplied = false;
 
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
      DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_DFIFF)
 
      if (!destination)
@@ -202,6 +208,7 @@
                                       data->base.render_callback_context );
      }
      
+     D_IMG_PRINTF("%s() return OK <---\n", __func__);
      return DFB_OK;
 }
 
@@ -251,9 +258,14 @@
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx )
 {
+     D_IMG_PRINTF( "Probe (DFIFF) ...\n");
      if (!strncmp( (const char*) ctx->header, "DFIFF", 5 ))
+     {
+          D_IMG_PRINTF( "    ==> DFIFF format!\n");
           return DFB_OK;
+     }
 
+     D_IMG_PRINTF( "    ==> NOT DFIFF format!\n");
      return DFB_UNSUPPORTED;
 }
 
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c	2016-07-03 13:50:07.659744322 +0200
@@ -55,6 +55,11 @@
 #include <direct/memcpy.h>
 #include <misc/util.h>
 
+#define D_IMG_PRINTF(x...)                                                           \
+     do {                                                                            \
+          if (direct_config->debug) printf( x );                 \
+     } while (0)
+
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
 
@@ -168,9 +173,14 @@
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx )
 {
+     D_IMG_PRINTF( "Probe (GIF) ...\n");
      if (strncmp ((char*) ctx->header, "GIF8", 4) == 0)
+     {
+          D_IMG_PRINTF( "    ==> GIF format!\n");
           return DFB_OK;
+     }
 
+     D_IMG_PRINTF( "    ==> NOT GIF format!\n");
      return DFB_UNSUPPORTED;
 }
 
@@ -236,6 +246,8 @@
      IDirectFBSurface_data *dst_data;
      CoreSurface           *dst_surface;
 
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
      DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_GIF)
 
      dst_data = (IDirectFBSurface_data*) destination->priv;
@@ -292,6 +304,7 @@
           }
      }
 
+     D_IMG_PRINTF("%s() return OK <---\n", __func__);
      return DFB_OK;
 }
 
@@ -661,6 +674,14 @@
                       interlace ? " interlaced" : "" );
      }
 
+	 // yducky: Support wrong interlace format: the GIF with small height(<5) can not be interlace type.
+     if(interlace){
+          if(height <= 4){
+               interlace = false;
+               GIFERRORMSG("Fixed non-interlace format!");
+          }
+     }
+
      while ((v = LWZReadByte( data, false, c )) >= 0 ) {
           u32 *dst = image + (ypos * width + xpos);
 
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2014-07-15 11:26:03.000000000 +0200
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c	2016-07-03 22:57:57.146594509 +0200
@@ -44,6 +44,7 @@
 #include <display/idirectfbsurface.h>
 
 #include <media/idirectfbimageprovider.h>
+#include <media/idirectfbdatabuffer.h>
 
 #include <core/layers.h>
 
@@ -56,12 +57,26 @@
 #include <direct/memcpy.h>
 #include <direct/messages.h>
 
+#include <gfx/util.h>
+
 #include <setjmp.h>
 #include <math.h>
 
+#if USE_RPC4DTV
+#include "ddi_gpu.h"
+#include <pthread.h>
+extern pthread_mutex_t g_dlfcn_mutex;
+#endif
+
 #undef HAVE_STDLIB_H
 #include <jpeglib.h>
 
+#define LG_CMYK_SUPPORT
+
+#define D_IMG_PRINTF(x...)                                                           \
+     do {                                                                            \
+          if (direct_config->debug) printf( x );                 \
+     } while (0)
 
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
@@ -74,6 +89,8 @@
 
 DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBImageProvider, JPEG )
 
+#define IMAGE_FROM_PATH 0
+
 /*
  * private data struct of IDirectFBImageProvider_JPEG
  */
@@ -97,6 +114,11 @@
                                       const DFBRectangle     *destination_rect );
 
 static DFBResult
+IDirectFBImageProvider_JPEG_HWRenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect );
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc );
 
@@ -225,6 +247,7 @@
 jpeglib_panic(j_common_ptr cinfo)
 {
      struct my_error_mgr *myerr = (struct my_error_mgr*) cinfo->err;
+     (*cinfo->err->output_message)(cinfo);
      longjmp(myerr->setjmp_buffer, 1);
 }
 
@@ -238,6 +261,18 @@
      }
 }
 
+
+#ifdef LG_CMYK_SUPPORT
+static inline void
+copy_line_cmyk( u32 *argb, const u8 *rgb, int width )
+{
+     while (width--) {
+          *argb++ = 0xFF000000 | (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
+          rgb += 4;
+     }
+}
+#endif
+
 static inline void
 copy_line_nv16( u16 *yy, u16 *cbcr, const u8 *src_ycbcr, int width )
 {
@@ -307,32 +342,146 @@
           D_FREE( data->image );
 }
 
+/* mini90 add - filter function used by scandir */
+static int filter(char* file_path)
+{
+     char *c_ptr1, *c_ptr2= NULL;
+
+     for(c_ptr1= file_path; *c_ptr1 != '\0'; c_ptr1++)
+     {
+          if(*c_ptr1=='.')
+               c_ptr2 = c_ptr1;
+     }
+
+     if(c_ptr2 != NULL)
+     {
+          c_ptr2++;
+
+          if(*c_ptr2 != '\0')
+               if(strncasecmp(c_ptr2, "JPG",3)==0)
+                    return 1;
+
+          if(*c_ptr2 != '\0')
+               if(strncasecmp(c_ptr2, "JPEG",4)==0)
+                    return 1;
+     }
+
+     return 0;
+}
+
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx )
 {
+     D_IMG_PRINTF( "Probe (JPG) ...\n");
      /* Look of the Jpeg SOI marker */
      if (ctx->header[0] == 0xff && ctx->header[1] == 0xd8) {
           /* Look for JFIF or Exif strings, also could look at header[3:2] for APP0(0xFFE0),
            * APP1(0xFFE1) or even other APPx markers.
            */
+          D_IMG_PRINTF("    JPEG SOI (0xFFD8) found!\n");
           if (strncmp ((char*) ctx->header + 6, "JFIF", 4) == 0 ||
               strncmp ((char*) ctx->header + 6, "Exif", 4) == 0 ||
               strncmp ((char*) ctx->header + 6, "VVL", 3) == 0 ||
-              strncmp ((char*) ctx->header + 6, "WANG", 4) == 0)
+              strncmp ((char*) ctx->header + 6, "WANG", 4) == 0 ||
+              strncmp ((char*) ctx->header + 6, "Lavc", 4) == 0)
+          {
+                D_IMG_PRINTF("    ==> JPEG format by ID!\n");
                return DFB_OK;
+          }
+          D_IMG_PRINTF("    JPEG Idendifier (JFIF,Exif,Lavc) NOT found!\n");
 
           /* Else look for Quantization table marker or Define Huffman table marker,
            * useful for EXIF thumbnails that have no APPx markers.
            */
           if (ctx->header[2] == 0xff && (ctx->header[3] == 0xdb || ctx->header[3] == 0xc4))
+          {
+               D_IMG_PRINTF("    ==> JPEG format by extension!\n");
                return DFB_OK;
+          }
 
+#if 0 /* this code has flaws in case of '../Photos/XXX.JPG' */
           if (ctx->filename && strchr (ctx->filename, '.' ) &&
              (strcasecmp ( strchr (ctx->filename, '.' ), ".jpg" ) == 0 ||
               strcasecmp ( strchr (ctx->filename, '.' ), ".jpeg") == 0))
                return DFB_OK;
      }
+#else
+          if (ctx->filename && filter((char*)(ctx->filename)))
+          {
+               D_IMG_PRINTF("    ==> JPEG format by extension!\n");
+               return DFB_OK;
+          }
+#endif
+
+          D_IMG_PRINTF("    JPEG extension (ex:.jpg) NOT found!\n");
+          /* 
+          This code is a workaround for multiple APPx marker in buffer mode (not file mode).
+
+          ----- JPEG Format Information -----
+          Every block is seperated by Marker.
+
+          *Marker without data (Marker[2bytes])
+          FFD0~FFD7: Restart1~7
+          FFD8: Start of Image (SOI) ---(*)
+          FFD9: End of Image (EOI)
+
+          *Marker with additional data (Marker[2bytes]+Size[2bytes]+Data[Size-2 bytes])
+          FFC0~FFC2: Start of Frame0~2
+          FFC4: Define Huffman Tables
+          FFDA: Start of Scan
+          FFDB: DQT (Define Quantization Tables)
+          FFDD: Define Restart Interval
+          FFE0~FFEF: Application specific data, APP0~15 ---(*)
+          FFFE: Comment
+
+          *Marker order 
+           : SOI, APP0, APPx, DQT, DHT, SOS, Data, EOI
+
+          In normal case APP0 marker and its identifier('JFIF') follow SOI
+           but few jpg files that saved by old application have APPx, not APP0, after SOI.
+          In this case we have to parse size and identifier of all APPx Markers
+           but it's not easy for current structure of DirectFB.
+          I apply a workaround that it checks SOI and APPx Marker range only if data is from buffer, not file.
+          In addition, DQT marker and size value are checked. The size value of DQT is the same to 0x43 (67=2+1+64) or  0x83 (131=2+1+128).
+          In file mode an extension of file is used for check jpg implementation.
+          */
+          if (!ctx->filename)
+          {
+               D_IMG_PRINTF("    Workaround Try in buffer mode!\n");
+               /* First, check SOI (0xffd8) */
+               if((ctx->header[0] == 0xff && ctx->header[1] == 0xd8))
+               {
+                    /* Case 1: try to check APPx marker range (0xffe0~0xffef) */
+                    if(ctx->header[2] == 0xff && (ctx->header[3] >= 0xe0 && ctx->header[3] <= 0xef)) 
+                    {
+                         D_IMG_PRINTF("    JPEG SOI and APPx Marker found!\n");
+                         /* check the first two characters are string for more accuracy. */
+                         if(ctx->header[6]>=0x30 && ctx->header[6]<=0x7a && ctx->header[7]>=0x30 && ctx->header[7]<=0x7a)
+                         {
+                              D_IMG_PRINTF("    JPEG two strings found! ==> JPEG format!\n");
+                              return DFB_OK;
+                         }
+                         D_IMG_PRINTF("    *** JPEG two strings NOT found! ***\n");
+                    }
+                    /* Case 2: try to check COM marker(0xfffe, commment marker). */
+                    else if((ctx->header[2]==0xff && ctx->header[3]==0xfe) )
+                    {
+                         D_IMG_PRINTF("    JPEG SOI and COM Marker found! ==> JPEG format!\n");
+                         return DFB_OK;
+                    }
 
+                    /* Case 3: try to check DQT marker(0xffdb) and size value (0x43 or 0x84). Case of no APPx marker. */
+                    else if((ctx->header[2]==0xff && ctx->header[3]==0xdb) && (ctx->header[4]==0x00) && (ctx->header[5]==0x43 || ctx->header[5]==0x84))
+                    {
+                         D_IMG_PRINTF("    JPEG SOI and DQT Marker and size found! ==> JPEG format!\n");
+                         return DFB_OK;
+                    }
+                    D_IMG_PRINTF("    ==> 0x%02x %02x %02x %02x %02x %02x %02x(%c) %02x(%c) %02x(%c) %02x(%c) ...\n", ctx->header[0], ctx->header[1], ctx->header[2], ctx->header[3], ctx->header[4], ctx->header[5], ctx->header[6], ctx->header[6], ctx->header[7], ctx->header[7], ctx->header[8], ctx->header[8], ctx->header[9], ctx->header[9]);
+               }
+          }
+          /* End of workaround */
+          D_IMG_PRINTF("    ==> Not JPEG format!\n");
+     }
      return DFB_UNSUPPORTED;
 }
 
@@ -402,8 +551,46 @@
      return DFB_OK;
 }
 
+/* min90 - add */
+static void make_scale(int t_width, int t_height, int width, int height, int* scale_num, int* scale_denom)
+{
+     float r1, r2, r;
+     int n;
+
+
+     r1 =  (float)t_width / (float)width;
+     r2 = (float)t_height / (float)height;
+
+     if(r1 > r2) r = r2;
+     else r = r1;
+
+
+     //	printf("r1:%f, r2:%f, r:%f\n", r1, r2, r);
+
+     if( r < 1){
+          n = r*8;
+          if(n < r*8) n++;
+          *scale_num = n ;
+          *scale_denom = 8;
+     }
+
+     switch(*scale_num)
+     {
+          case 7:
+          case 6:
+          case 5:
+               *scale_num = 8;
+               break;
+          case 3:
+               *scale_num = 4;
+               break;
+          default:
+               break;
+     }
+}
+
 static DFBResult
-IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
+IDirectFBImageProvider_JPEG_SWRenderTo( IDirectFBImageProvider *thiz,
                                       IDirectFBSurface       *destination,
                                       const DFBRectangle     *dest_rect )
 {
@@ -416,6 +603,7 @@
      CoreSurface           *dst_surface;
      CoreSurfaceBufferLock  lock;
      DIRenderCallbackResult cb_result = DIRCR_OK;
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
 
      DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
 
@@ -460,6 +648,7 @@
            data->image_height = 0;
      }
 
+     D_IMG_PRINTF("    actual loding and rendering...\n");
      /* actual loading and rendering */
      if (!data->image) {
           struct jpeg_decompress_struct cinfo;
@@ -540,8 +729,12 @@
 #endif
           }
 
+#ifdef LG_CMYK_SUPPORT
+		  if(cinfo.comps_in_scan != 4)
           cinfo.output_components = 3;
-
+#else
+          cinfo.output_components = 3;
+#endif
           switch (dst_surface->config.format) {
                case DSPF_NV16:
                     uv_offset = dst_surface->config.size.h * lock.pitch;
@@ -568,19 +761,35 @@
                     break;
 
                default:
+#ifdef LG_CMYK_SUPPORT
+                    if(cinfo.comps_in_scan == 4)
+                        cinfo.out_color_space = JCS_CMYK; 
+                    else
+                        cinfo.out_color_space = JCS_RGB; 
+#else
                     cinfo.out_color_space = JCS_RGB;
+#endif
                     break;
           }
 
           if (data->flags & DIRENDER_FAST)
                cinfo.dct_method = JDCT_IFAST;
 
+/* min90 - add */
+          cinfo.dct_method = JDCT_FASTEST;
+          if(dest_rect)
+               make_scale(rect.w, rect.h, cinfo.image_width, cinfo.image_height, &cinfo.scale_num, &cinfo.scale_denom);
+
           jpeg_start_decompress( &cinfo );
 
           data->image_width = cinfo.output_width;
           data->image_height = cinfo.output_height;
 
+#ifdef LG_CMYK_SUPPORT
+          row_stride = cinfo.output_width * cinfo.output_components;
+#else
           row_stride = cinfo.output_width * 3;
+#endif
 
           buffer = (*cinfo.mem->alloc_sarray)( (j_common_ptr) &cinfo,
                                                JPOOL_IMAGE, row_stride, 1 );
@@ -624,7 +833,14 @@
                          }
 
                     default:
+#ifdef LG_CMYK_SUPPORT
+                         if(cinfo.out_color_space == JCS_CMYK)
+                             copy_line_cmyk( row_ptr, *buffer, data->width);
+                         else
+                             copy_line32( row_ptr, *buffer, data->width);
+#else
                          copy_line32( row_ptr, *buffer, data->image_width );
+#endif
 
                          if (direct) {
                               DFBRectangle r = { rect.x, rect.y+y, rect.w, 1 };
@@ -677,11 +893,287 @@
 
      if (cb_result != DIRCR_OK)
           return DFB_INTERRUPTED;
+     D_IMG_PRINTF("%s() return OK <---\n", __func__);
 
      return DFB_OK;
 }
 
 static DFBResult
+IDirectFBImageProvider_JPEG_HWRenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     DFBResult              ret;
+     DFBRegion              clip;
+     DFBRectangle           rect;
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+
+#if IMAGE_FROM_PATH 
+     IDirectFBDataBuffer_data            *buffer_data;
+     static char                   file_path[1024];
+#endif
+     GPU_IMAGE_INFO_T imageInfo;
+     GPU_SURFACE_INFO_T surfaceInfo;
+
+     CoreSurfaceBufferLock  dst_lock;
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
+     DIRECT_INTERFACE_GET_DATA(IDirectFBImageProvider_JPEG)
+
+     if(data->width * data->height > 921600 )  // 921600 = 1280*720
+     {
+          // Let's use S/W decoder with down-scailing to save memory.
+          return DFB_FAILURE;
+     }
+
+     if(data->width * data->height < 57600)  // 320x180 is for Vudu thumbnail
+     {
+          // it's better to use S/W render for small images..
+          return DFB_FAILURE;
+     }
+
+#if USE_RPC4DTV
+          if(!DDI_GPU_DecodeImage)
+          {
+               assign_symbol_DDI_GPU_FUNCS(&g_dlfcn_mutex);
+               if(!DDI_GPU_DecodeImage)
+               {
+                    return DFB_FAILURE;
+               }
+          }
+#else
+     return DFB_FAILURE;
+#endif
+     D_IMG_PRINTF("    Size OK!\n");
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1)
+               return DFB_INVARG;
+
+          rect = *dest_rect;
+          rect.x += dst_data->area.wanted.x;
+          rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &rect, &clip ))
+               return DFB_OK;
+     }
+     else {
+          rect = dst_data->area.wanted;
+     }
+
+#if USE_RPC4DTV
+     {
+          imageInfo.imagePtr = NULL;
+          imageInfo.imagePath = NULL;
+          imageInfo.imageLength = 0;
+
+          /* common settings for imageInfo */
+          imageInfo.imageFormat = GPU_IMAGE_FORMAT_JPEG;
+          imageInfo.rect.x = rect.x;
+          imageInfo.rect.y = rect.y;
+          imageInfo.rect.w = rect.w;
+          imageInfo.rect.h = rect.h;
+
+#if IMAGE_FROM_PATH 
+          D_IMG_PRINTF("    File mode\n");
+          /* Get the private information of the data buffer. */
+          buffer_data = (IDirectFBDataBuffer_data*) data->base.buffer->priv;
+          if (!buffer_data)
+               return DFB_DEAD;
+
+          if(!buffer_data->filename)  // Decoding from image file path
+#else
+          D_IMG_PRINTF("    Buffer mode\n");
+#endif
+          {  // Decoding from buffered image
+
+               int read = 0;
+               int total_read = 0;
+
+               imageInfo.bImageFromBuffer = 1;
+
+               if( DFB_OK != data->base.buffer->SeekTo(data->base.buffer, 0))
+               {
+                    return DFB_FAILURE;
+               }
+
+               if( DFB_OK != data->base.buffer->GetLength(data->base.buffer, &imageInfo.imageLength))
+               {
+                    return DFB_FAILURE;
+               }
+
+               if(imageInfo.imageLength > 0 && imageInfo.imageLength < 512*1024 )  // 512*1024 is RPC_SMEM_SIZE, refer to ipc_unix.h
+               {
+                    imageInfo.imagePtr = malloc(imageInfo.imageLength);
+
+                    if(imageInfo.imagePtr == NULL)
+                    {
+                         return DFB_FAILURE;
+                    }
+               } else {
+                    D_IMG_PRINTF("    Failed: Raw data is greater than RPC_SMEM_SIZE(512KB)\n");
+                    return DFB_FAILURE;
+               }
+
+               total_read = 0;
+               do
+               {
+                    if( DFB_OK != data->base.buffer->PeekData(data->base.buffer, imageInfo.imageLength-total_read, total_read, (char*)imageInfo.imagePtr + total_read, &read))
+                    {
+                         return DFB_FAILURE;
+                    }
+                    total_read += read;
+               } while( total_read < imageInfo.imageLength );
+
+			   data->base.buffer->SeekTo(data->base.buffer, 0);
+          }
+#if IMAGE_FROM_PATH 
+		  else {
+               imageInfo.bImageFromBuffer = 0;
+
+               if(buffer_data->filename[0] == '.')
+               {
+                    strncpy(file_path, getcwd(NULL,0), 1024);
+                    strncat(file_path, "/", 1024);
+                    strncat(file_path, buffer_data->filename, 1024);
+               } else
+               {
+                    strncpy(file_path, buffer_data->filename, 1024);
+               }
+
+               imageInfo.imagePath = file_path;
+
+          }
+#endif
+     }
+
+     ret = dfb_surface_lock_buffer( dst_surface, CSBR_FRONT, CSAF_READ, CSAF_WRITE, &dst_lock );
+     if (ret) {
+          if(imageInfo.imagePtr)
+          {
+               free(imageInfo.imagePtr);
+          }
+          return DFB_FAILURE;
+     }
+
+     surfaceInfo.offset = dst_lock.offset;
+     surfaceInfo.pitch = dst_lock.pitch;
+     surfaceInfo.width = dst_data->surface->config.size.w;//dst_data->area.current.w;
+     surfaceInfo.height = dst_data->surface->config.size.h;//dst_data->area.current.h;
+
+     GPU_PIXEL_FORMAT_T format;
+     int bpp=0;
+     switch(dst_data->surface->config.format)
+     {
+          case DSPF_ARGB:
+               format = GPU_PIXEL_FORMAT_ARGB;
+               bpp = 32;
+               break;
+          case DSPF_LUT8:
+               format = GPU_PIXEL_FORMAT_LUT8;
+               bpp = 8;
+               break;
+          case DSPF_ARGB1555:
+               format = GPU_PIXEL_FORMAT_ARGB1555;
+               bpp = 16;
+               break;
+          case DSPF_RGB16:
+               format = GPU_PIXEL_FORMAT_RGB16;
+               bpp = 16;
+               break;
+          case DSPF_ARGB4444:
+               format = GPU_PIXEL_FORMAT_ARGB4444;
+               bpp = 16;
+               break;
+          case DSPF_A8:
+               format = GPU_PIXEL_FORMAT_A8;
+               bpp = 8;
+               break;
+
+          default:
+               format = -1;
+               break;
+     }
+
+     surfaceInfo.pixelFormat = format;
+     surfaceInfo.bpp = bpp;
+	
+     GPU_DECODEIMAGE_FLAGS_T decodeFlags;
+#if 0
+     DFBSurfaceDescription  desc;
+     DFBSurfaceCapabilities caps;
+     destination->GetCapabilities( destination, &caps );
+     thiz->GetSurfaceDescription( thiz, &desc );
+     
+     if (caps & DSCAPS_PREMULTIPLIED && DFB_PIXELFORMAT_HAS_ALPHA(desc.pixelformat))
+          decodeFlags = GPU_DECODEIMAGE_PREMULTIPLY;
+     else
+          decodeFlags = GPU_DECODEIMAGE_NOFX;
+#else
+	 //jpeg does not have Alpha value.
+     decodeFlags = GPU_DECODEIMAGE_NOFX;
+#endif
+     D_IMG_PRINTF("    call DDI_GPU_DecodeImage()\n");
+
+     if(OK != DDI_GPU_DecodeImage(imageInfo, surfaceInfo, decodeFlags))
+     {
+          D_IMG_PRINTF("    Failure from DDI_GPU_DecodeImage()\n");
+          dfb_surface_unlock_buffer( dst_surface, &dst_lock);
+          if(imageInfo.imagePtr)
+          {
+               free(imageInfo.imagePtr);
+          }
+          return DFB_FAILURE;
+     }
+     D_IMG_PRINTF("    Success from DDI_GPU_DecodeImage()\n");
+     dfb_surface_unlock_buffer( dst_surface, &dst_lock);
+
+     if(imageInfo.imagePtr)
+     {
+          free(imageInfo.imagePtr);
+     }
+     D_IMG_PRINTF("%s() return OK <---\n", __func__);
+     
+     return DFB_OK;
+#endif
+}
+
+static DFBResult
+IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     DFBResult ret;
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
+#if USE_RPC4DTV
+     ret = IDirectFBImageProvider_JPEG_HWRenderTo(thiz, destination, dest_rect);
+     if( ret != DFB_OK )
+     {
+          ret = IDirectFBImageProvider_JPEG_SWRenderTo(thiz, destination, dest_rect);
+     }
+
+     D_IMG_PRINTF("%s() return %d <---\n", __func__, ret);
+	 return ret;
+#else
+     ret = IDirectFBImageProvider_JPEG_SWRenderTo(thiz, destination, dest_rect);
+     D_IMG_PRINTF("%s() return %d <---\n", __func__, ret);
+     return ret;
+#endif
+}
+
+static DFBResult
 IDirectFBImageProvider_JPEG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                    DFBSurfaceDescription  *dsc )
 {
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2016-07-03 22:58:09.857126563 +0200
@@ -45,6 +45,7 @@
 #include <display/idirectfbsurface.h>
 
 #include <media/idirectfbimageprovider.h>
+#include <media/idirectfbdatabuffer.h>
 
 #include <core/coredefs.h>
 #include <core/coretypes.h>
@@ -77,6 +78,17 @@
 #define trans_alpha  trans
 #endif
 
+#if USE_RPC4DTV
+#include "ddi_gpu.h"
+#include <pthread.h>
+extern pthread_mutex_t g_dlfcn_mutex;
+#endif
+
+#define D_IMG_PRINTF(x...)                                                           \
+     do {                                                                            \
+          if (direct_config->debug) printf( x );                 \
+     } while (0)
+
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx );
 
@@ -98,6 +110,8 @@
      STAGE_END
 };
 
+#define IMAGE_FROM_PATH 0
+
 /*
  * private data struct of IDirectFBImageProvider_PNG
  */
@@ -266,7 +280,7 @@
 /**********************************************************************************************************************/
 
 static DFBResult
-IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
+IDirectFBImageProvider_PNG_SWRenderTo( IDirectFBImageProvider *thiz,
                                      IDirectFBSurface       *destination,
                                      const DFBRectangle     *dest_rect )
 {
@@ -323,6 +337,7 @@
           data->stage = STAGE_ERROR;
      }
 
+     D_IMG_PRINTF("    Read until image is completely decoded!\n", __func__);
      /* Read until image is completely decoded. */
      if (data->stage != STAGE_ERROR) {
           ret = push_data_until_stage( data, STAGE_END, 16384 );
@@ -339,6 +354,7 @@
 
      D_DEBUG_AT( imageProviderPNG, "  -> clipped   %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS(&clipped) );
 
+     D_IMG_PRINTF("    Actual rendering!\n", __func__);
      /* actual rendering */
      if (0    &&   // FIXME
            rect.w == data->width && rect.h == data->height &&
@@ -505,10 +521,282 @@
      if (data->stage != STAGE_END)
           ret = DFB_INCOMPLETE;
 
+     D_IMG_PRINTF("%s() return %d <---\n", __func__, ret);
      return ret;
 }
 
 static DFBResult
+IDirectFBImageProvider_PNG_HWRenderTo( IDirectFBImageProvider *thiz,
+                                     IDirectFBSurface       *destination,
+                                     const DFBRectangle     *dest_rect )
+{
+     DFBResult              ret;
+     DFBRegion              clip;
+     DFBRectangle           rect;
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *dst_surface;
+
+#if IMAGE_FROM_PATH 
+     IDirectFBDataBuffer_data            *buffer_data;
+     static char                   file_path[1024];
+#endif
+     GPU_IMAGE_INFO_T imageInfo;
+     GPU_SURFACE_INFO_T surfaceInfo;
+
+     CoreSurfaceBufferLock  dst_lock;
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
+     DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
+
+#if USE_RPC4DTV
+          if(!DDI_GPU_DecodeImage)
+          {
+               assign_symbol_DDI_GPU_FUNCS(&g_dlfcn_mutex);
+               if(!DDI_GPU_DecodeImage)
+               {
+                    return DFB_FAILURE;
+               }
+          }
+#else
+     return DFB_FAILURE;
+#endif
+
+     if(data->width * data->height > 921600 )  // 921600 = 1280*720
+     {
+          // Let's use S/W decoder with down-scailing to save memory.
+          return DFB_FAILURE;
+     }
+
+     if(data->width * data->height < 60000)
+     {
+          // it's better to use S/W render for small images..
+          return DFB_FAILURE;
+     }
+
+     dst_data = (IDirectFBSurface_data*) destination->priv;
+     if (!dst_data)
+          return DFB_DEAD;
+
+     dst_surface = dst_data->surface;
+     if (!dst_surface)
+          return DFB_DESTROYED;
+
+     dfb_region_from_rectangle( &clip, &dst_data->area.current );
+
+     if (dest_rect) {
+          if (dest_rect->w < 1 || dest_rect->h < 1)
+               return DFB_INVARG;
+
+          rect = *dest_rect;
+          rect.x += dst_data->area.wanted.x;
+          rect.y += dst_data->area.wanted.y;
+
+          if (!dfb_rectangle_region_intersects( &rect, &clip ))
+               return DFB_OK;
+     }
+     else {
+          rect = dst_data->area.wanted;
+     }
+
+#if USE_RPC4DTV
+     {
+          imageInfo.imagePtr = NULL;
+          imageInfo.imagePath = NULL;
+          imageInfo.imageLength = 0;
+
+          /* common settings for imageInfo */
+          imageInfo.imageFormat = GPU_IMAGE_FORMAT_PNG;
+          imageInfo.rect.x = rect.x;
+          imageInfo.rect.y = rect.y;
+          imageInfo.rect.w = rect.w;
+          imageInfo.rect.h = rect.h;
+
+#if IMAGE_FROM_PATH 
+          /* Get the private information of the data buffer. */
+          buffer_data = (IDirectFBDataBuffer_data*) data->base.buffer->priv;
+          if (!buffer_data)
+               return DFB_DEAD;
+
+          if(!buffer_data->filename)  // Decoding from image file path
+#endif
+          {  // Decoding from buffered image
+
+               int read = 0;
+               int total_read = 0;
+               unsigned int position_backup=0;
+
+               imageInfo.bImageFromBuffer = 1;
+
+               if( DFB_OK != data->base.buffer->GetPosition(data->base.buffer, &position_backup))
+               {
+                    return DFB_FAILURE;
+               }
+
+               if( DFB_OK != data->base.buffer->SeekTo(data->base.buffer, 0))
+               {
+                    return DFB_FAILURE;
+               }
+
+               if( DFB_OK != data->base.buffer->GetLength(data->base.buffer, &imageInfo.imageLength))
+               {
+                    data->base.buffer->SeekTo(data->base.buffer, position_backup);
+                    return DFB_FAILURE;
+               }
+
+               if(imageInfo.imageLength > 0 && imageInfo.imageLength < 512*1024 )  // 512*1024 is RPC_SMEM_SIZE, refer to ipc_unix.h
+               {
+                    imageInfo.imagePtr = malloc(imageInfo.imageLength);
+
+                    if(imageInfo.imagePtr == NULL)
+                    {
+                         data->base.buffer->SeekTo(data->base.buffer, position_backup);
+                         return DFB_FAILURE;
+                    }
+               } else {
+                    data->base.buffer->SeekTo(data->base.buffer, position_backup);
+                    return DFB_FAILURE;
+               }
+
+               total_read = 0;
+               do
+               {
+                    if( DFB_OK != data->base.buffer->PeekData(data->base.buffer, imageInfo.imageLength-total_read, total_read, (char*)imageInfo.imagePtr + total_read, &read))
+                    {
+                         return DFB_FAILURE;
+                    }
+                    total_read += read;
+               } while( total_read < imageInfo.imageLength );
+
+               data->base.buffer->SeekTo(data->base.buffer, position_backup);
+          } 
+#if IMAGE_FROM_PATH 
+		  else {
+               imageInfo.bImageFromBuffer = 0;
+
+               if(buffer_data->filename[0] == '.')
+               {
+                    strncpy(file_path, getcwd(NULL,0), 1024);
+                    strncat(file_path, "/", 1024);
+                    strncat(file_path, buffer_data->filename, 1024);
+               } else
+               {
+                    strncpy(file_path, buffer_data->filename, 1024);
+               }
+
+               imageInfo.imagePath = file_path;
+
+          }
+#endif
+     }
+
+     ret = dfb_surface_lock_buffer( dst_surface, CSBR_FRONT, CSAF_READ, CSAF_WRITE, &dst_lock );
+     if (ret) {
+          if(imageInfo.imagePtr)
+          {
+               free(imageInfo.imagePtr);
+          }
+          return DFB_FAILURE;
+     }
+
+     surfaceInfo.offset = dst_lock.offset;
+     surfaceInfo.pitch = dst_lock.pitch;
+     surfaceInfo.width = dst_data->surface->config.size.w;//dst_data->area.current.w;
+     surfaceInfo.height = dst_data->surface->config.size.h;//dst_data->area.current.h;
+
+     GPU_PIXEL_FORMAT_T format;
+     int bpp=0;
+     switch(dst_data->surface->config.format)
+     {
+          case DSPF_ARGB:
+               format = GPU_PIXEL_FORMAT_ARGB;
+               bpp = 32;
+               break;
+          case DSPF_LUT8:
+               format = GPU_PIXEL_FORMAT_LUT8;
+               bpp = 8;
+               break;
+          case DSPF_ARGB1555:
+               format = GPU_PIXEL_FORMAT_ARGB1555;
+               bpp = 16;
+               break;
+          case DSPF_RGB16:
+               format = GPU_PIXEL_FORMAT_RGB16;
+               bpp = 16;
+               break;
+          case DSPF_ARGB4444:
+               format = GPU_PIXEL_FORMAT_ARGB4444;
+               bpp = 16;
+               break;
+          case DSPF_A8:
+               format = GPU_PIXEL_FORMAT_A8;
+               bpp = 8;
+               break;
+
+          default:
+               format = -1;
+               break;
+     }
+
+     surfaceInfo.pixelFormat = format;
+     surfaceInfo.bpp = bpp;
+
+     DFBSurfaceDescription  desc;
+     DFBSurfaceCapabilities caps;
+     GPU_DECODEIMAGE_FLAGS_T decodeFlags;
+     destination->GetCapabilities( destination, &caps );
+     thiz->GetSurfaceDescription( thiz, &desc );
+     
+     if (caps & DSCAPS_PREMULTIPLIED && DFB_PIXELFORMAT_HAS_ALPHA(desc.pixelformat))
+          decodeFlags = GPU_DECODEIMAGE_PREMULTIPLY;
+     else
+          decodeFlags = GPU_DECODEIMAGE_NOFX;
+
+     if(OK != DDI_GPU_DecodeImage(imageInfo, surfaceInfo, decodeFlags))
+     {
+          dfb_surface_unlock_buffer( dst_surface, &dst_lock);
+          if(imageInfo.imagePtr)
+          {
+               free(imageInfo.imagePtr);
+          }
+          return DFB_FAILURE;
+     }
+     dfb_surface_unlock_buffer( dst_surface, &dst_lock);
+
+     if(imageInfo.imagePtr)
+     {
+          free(imageInfo.imagePtr);
+     }
+     D_IMG_PRINTF("%s() return OK <---\n", __func__);
+     
+     return DFB_OK;
+#endif
+}
+
+static DFBResult
+IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
+                                      IDirectFBSurface       *destination,
+                                      const DFBRectangle     *dest_rect )
+{
+     DFBResult ret;
+     D_IMG_PRINTF("%s() begin --->\n", __func__);
+
+#if USE_RPC4DTV
+     ret = IDirectFBImageProvider_PNG_HWRenderTo(thiz, destination, dest_rect);
+     if( ret != DFB_OK )
+     {
+          ret = IDirectFBImageProvider_PNG_SWRenderTo(thiz, destination, dest_rect);
+     }
+
+      D_IMG_PRINTF("%s() return %d <---\n", __func__, ret);
+	 return ret;
+#else
+     ret = IDirectFBImageProvider_PNG_SWRenderTo(thiz, destination, dest_rect);
+     D_IMG_PRINTF("%s() return %d <---\n", __func__, ret);
+     return ret;
+#endif
+}
+
+static DFBResult
 IDirectFBImageProvider_PNG_GetSurfaceDescription( IDirectFBImageProvider *thiz,
                                                   DFBSurfaceDescription  *dsc )
 {
diff -ruNb DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/Makefile.am DirectFB-1.7.7/interfaces/IDirectFBImageProvider/Makefile.am
--- DirectFB-1.7.7_orig/interfaces/IDirectFBImageProvider/Makefile.am	2014-03-22 21:05:18.000000000 +0100
+++ DirectFB-1.7.7/interfaces/IDirectFBImageProvider/Makefile.am	2016-07-03 13:53:24.266815506 +0200
@@ -4,6 +4,12 @@
 
 idirectfbimageproviderdir = $(MODULEDIR)/interfaces/IDirectFBImageProvider
 
+if CIF_PROVIDER
+CIF_PROVIDER_LTLIB = libidirectfbimageprovider_cif.la
+else
+CIF_PROVIDER_LTLIB = 
+endif
+
 
 if GIF_PROVIDER
 GIF_PROVIDER_LTLIB = libidirectfbimageprovider_gif.la
@@ -92,6 +98,7 @@
 	$(GIF_PROVIDER_LTLIB)			\
 	$(JPEG_PROVIDER_LTLIB)			\
 	$(PNG_PROVIDER_LTLIB)			\
+	$(CIF_PROVIDER_LTLIB)		\
 	$(IMLIB2_PROVIDER)			\
 	$(PNM_PROVIDER)				\
 	$(SVG_PROVIDER)				\
@@ -162,4 +169,13 @@
 libidirectfbimageprovider_ffmpeg_la_LIBADD = $(libdirect) $(libdirectfb) $(FFMPEG_LIBS)
 libidirectfbimageprovider_ffmpeg_la_LDFLAGS = -avoid-version -module -lavformat -lavutil -lavcodec -lswscale
 
+libidirectfbimageprovider_cif_la_SOURCES = idirectfbimageprovider_cif.c
+
+libidirectfbimageprovider_cif_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+libidirectfbimageprovider_cif_la_LDFLAGS = -avoid-version -module
+
+
 include $(top_srcdir)/rules/libobject.make
diff -ruNb DirectFB-1.7.7_orig/lib/direct/interface.c DirectFB-1.7.7/lib/direct/interface.c
--- DirectFB-1.7.7_orig/lib/direct/interface.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/lib/direct/interface.c	2016-07-03 13:50:07.663744319 +0200
@@ -173,7 +173,7 @@
      D_DEBUG_AT( Direct_Interface, "  -> %p\n", impl );
 
      D_MAGIC_CLEAR( impl );
-
+     D_FREE(impl->filename);
      D_FREE( impl );
 }
 
diff -ruNb DirectFB-1.7.7_orig/lib/direct/modules.c DirectFB-1.7.7/lib/direct/modules.c
--- DirectFB-1.7.7_orig/lib/direct/modules.c	2014-07-15 08:54:58.000000000 +0200
+++ DirectFB-1.7.7/lib/direct/modules.c	2016-07-03 21:46:53.990418711 +0200
@@ -46,6 +46,9 @@
 #include <alloca.h>
 #include <dirent.h>
 #include <dlfcn.h>
+#include <pthread.h>
+
+pthread_mutex_t g_dlfcn_mutex = PTHREAD_MUTEX_INITIALIZER;
 #endif
 
 D_LOG_DOMAIN( Direct_Modules, "Direct/Modules", "Module loading and registration" );
@@ -173,6 +176,8 @@
      D_MAGIC_ASSERT( entry, DirectModuleEntry );
 
      D_FREE( entry->name );
+     if (entry->file)
+           D_FREE( entry->file );
 
      direct_list_remove( &directory->entries, &entry->link );
 
@@ -436,8 +441,10 @@
           module->handle = NULL;
           module->loaded = false;
 
+          pthread_mutex_lock( &g_dlfcn_mutex );
           /* may call direct_modules_unregister() */
           dlclose( handle );
+          pthread_mutex_unlock( &g_dlfcn_mutex );
      }
 }
 
@@ -474,7 +481,10 @@
 
      D_DEBUG_AT( Direct_Modules, "Loading '%s'...\n", buf );
 
+     pthread_mutex_lock( &g_dlfcn_mutex );
      handle = dlopen( buf, RTLD_NOW );
+     pthread_mutex_unlock( &g_dlfcn_mutex );
+
      D_DEBUG_AT( Direct_Modules, "  -> dlopen returned %p\n", handle );
      if (!handle)
           D_DLERROR( "Direct/Modules: Unable to dlopen `%s'!\n", buf );
diff -ruNb DirectFB-1.7.7_orig/lib/fusion/fusion.c DirectFB-1.7.7/lib/fusion/fusion.c
--- DirectFB-1.7.7_orig/lib/fusion/fusion.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/lib/fusion/fusion.c	2016-07-03 13:50:07.667744316 +0200
@@ -492,8 +492,8 @@
                     close( world->fusion_fd );
 
                     /* Free local world data. */
-                    D_MAGIC_CLEAR( world );
-                    D_FREE( world );
+                    D_MAGIC_CLEAR( world ); // min90 - comment out?
+                    D_FREE( world ); // min90 - commnet out?
 
                     break;
 
@@ -788,6 +788,10 @@
 
      /* Initialize shared data. */
      if (enter.fusion_id == FUSION_ID_MASTER) {
+#if GFXDRV_BCM3549 | GFXDRV_BCM3553
+          memset(shared, 0, sizeof(FusionWorldShared));
+#endif
+
           /* Initialize reference counter. */
           shared->refs = 1;
           
diff -ruNb DirectFB-1.7.7_orig/src/core/gfxcard.c DirectFB-1.7.7/src/core/gfxcard.c
--- DirectFB-1.7.7_orig/src/core/gfxcard.c	2015-02-11 15:43:51.000000000 +0100
+++ DirectFB-1.7.7/src/core/gfxcard.c	2016-07-03 13:50:07.671744313 +0200
@@ -77,6 +77,11 @@
 #include <misc/conf.h>
 #include <misc/util.h>
 
+#if 0
+//#if USE_RPC4DTV & USE_VIRTUALFB
+#include "rpc_ddi_gpu.h"
+#endif
+
 
 D_DEBUG_DOMAIN( Core_Graphics,    "Core/Graphics",    "DirectFB Graphics Core" );
 D_DEBUG_DOMAIN( Core_GraphicsOps, "Core/GraphicsOps", "DirectFB Graphics Core Operations" );
@@ -1561,6 +1566,15 @@
      if (dfb_config->task_manager)
           return;
 
+#if 0
+//#if USE_VIRTUALFB
+     if((state->destination->type & CSTF_LAYER) && (state->destination->resource_id == DLID_PRIMARY) && (state->to == CSBR_FRONT))
+     {
+          //printf("type:%d, id:%d, to:%d\n", state->destination->type, state->destination->resource_id, state->to);
+          return;
+     }
+#endif
+
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
 
@@ -2241,6 +2255,41 @@
      if (dfb_config->task_manager)
           return;
 
+//#if USE_VIRTUALFB
+#if 0
+     if((state->source->type & CSTF_LAYER) && (state->source->resource_id == DLID_PRIMARY) && (state->from == CSBR_BACK))
+     {
+          if((state->destination->type & CSTF_LAYER) && (state->destination->resource_id == DLID_PRIMARY) && (state->to == CSBR_FRONT))
+          {
+               CoreSurfaceBuffer *src_buffer;
+               //printf("type:%d, id:%d, to:%d ->", state->source->type, state->source->resource_id, state->from);
+               //printf("type:%d, id:%d, to:%d\n", state->destination->type, state->destination->resource_id, state->to);
+
+               src_buffer = dfb_surface_get_buffer( state->source, state->from );
+               D_MAGIC_ASSERT( src_buffer, CoreSurfaceBuffer );
+
+               if (src_buffer->policy == CSP_VIDEOONLY)
+               {
+#if USE_RPC4DTV
+                    if(DDI_GPU_UpdateScreen)
+                    {
+                         DDI_GPU_UpdateScreen();
+                    }
+                    else
+                    {
+                         assign_symbol_DDI_GPU_FUNCS();
+                         if(DDI_GPU_UpdateScreen)
+                         {
+                              DDI_GPU_UpdateScreen();
+                         }
+                    }
+#endif
+                    return;
+               }
+          }
+     }
+#endif
+
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
 
@@ -3087,6 +3136,24 @@
                }
           }
      }
+#if 0
+//#if USE_VIRTUALFB & USE_RPC4DTV
+     if((state->destination->type & CSTF_LAYER) && (state->destination->resource_id == DLID_PRIMARY) && (state->to == CSBR_FRONT))
+     {
+          if(DDI_GPU_UpdateScreen)
+          {
+               DDI_GPU_UpdateScreen();
+          }
+          else
+          {
+               assign_symbol_DDI_GPU_FUNCS();
+               if(DDI_GPU_UpdateScreen)
+               {
+                    DDI_GPU_UpdateScreen();
+               }
+          }
+     }
+#endif
 
      dfb_state_unlock( state );
 }
diff -ruNb DirectFB-1.7.7_orig/src/core/layer_context.c DirectFB-1.7.7/src/core/layer_context.c
--- DirectFB-1.7.7_orig/src/core/layer_context.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/core/layer_context.c	2016-07-03 13:50:07.671744313 +0200
@@ -1212,11 +1212,13 @@
      if (dfb_layer_context_lock( context ))
           return DFB_FUSION;
 
+#if 0
      /* Do nothing if the opacity didn't change. */
      if (context->primary.config.opacity == opacity) {
           dfb_layer_context_unlock( context );
           return DFB_OK;
      }
+#endif
 
      /* Take the current configuration. */
      config = context->primary.config;
diff -ruNb DirectFB-1.7.7_orig/src/core/layer_region.c DirectFB-1.7.7/src/core/layer_region.c
--- DirectFB-1.7.7_orig/src/core/layer_region.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/core/layer_region.c	2016-07-03 13:50:07.671744313 +0200
@@ -588,6 +588,7 @@
                          /* Just do the hardware independent work. */
                          dfb_surface_flip_buffers( surface, false );
                     }
+					if(ret == DFB_OK) // yducky - Check the FilpRegion() result to decide whether going to fallback or not.
                     break;
                }
 
diff -ruNb DirectFB-1.7.7_orig/src/core/local_surface_pool.c DirectFB-1.7.7/src/core/local_surface_pool.c
--- DirectFB-1.7.7_orig/src/core/local_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/src/core/local_surface_pool.c	2016-07-03 14:34:28.500809376 +0200
@@ -32,6 +32,8 @@
 
 #include <config.h>
 
+#include <string.h>
+
 #include <direct/debug.h>
 #include <direct/mem.h>
 
@@ -176,11 +178,17 @@
 #endif
           /* Create un-aligned local system surface buffer. */
 
-          dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size );
+          dfb_surface_calc_buffer_size( surface, 4, 0, &alloc->pitch, &alloc->size );
+          //dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size ); - Fix_me for vudu
 
           alloc->addr = D_MALLOC( alloc->size );
           if (!alloc->addr)
                return D_OOM();
+
+          /* Double check, in cases of developers who assumes that the surface is initialzed with 0x0. */
+          D_DEBUG("surface memory allocated in system memory.. size:%d\n", alloc->size);
+          memset(alloc->addr, 0x0, alloc->size);
+
 #ifndef ANDROID_NDK
      }
 #endif
diff -ruNb DirectFB-1.7.7_orig/src/core/Makefile.am DirectFB-1.7.7/src/core/Makefile.am
--- DirectFB-1.7.7_orig/src/core/Makefile.am	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/core/Makefile.am	2016-07-03 13:50:07.667744316 +0200
@@ -114,6 +114,9 @@
 	wm.h			\
 	wm_module.h
 
+#if ENABLE_VIRTUALFB
+#AM_CFLAGS = -DUSE_VIRTUALFB=1
+#endif
 
 noinst_LTLIBRARIES = libdirectfb_core.la
 
diff -ruNb DirectFB-1.7.7_orig/src/core/shared_surface_pool.c DirectFB-1.7.7/src/core/shared_surface_pool.c
--- DirectFB-1.7.7_orig/src/core/shared_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/src/core/shared_surface_pool.c	2016-07-03 15:08:10.564612102 +0200
@@ -178,7 +178,8 @@
      else {
           /* Create un-aligned shared system surface buffer. */
 
-          dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size );
+          dfb_surface_calc_buffer_size( surface, 4, 0, &alloc->pitch, &alloc->size );
+          //dfb_surface_calc_buffer_size( surface, 8, 0, &alloc->pitch, &alloc->size ); - Fix_me for vudu
 
           alloc->addr = SHMALLOC( data->shmpool, alloc->size );
           if (!alloc->addr)
diff -ruNb DirectFB-1.7.7_orig/src/core/surface.c DirectFB-1.7.7/src/core/surface.c
--- DirectFB-1.7.7_orig/src/core/surface.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/core/surface.c	2016-07-03 13:50:07.675744311 +0200
@@ -1708,6 +1708,9 @@
           }
 
           dfb_surface_notify( surface, CSNF_PALETTE_CHANGE );
+#if USE_RPC4DTV
+		  surface->palette_updated = 1;
+#endif
      }
 
      fusion_skirmish_dismiss( &surface->lock );
diff -ruNb DirectFB-1.7.7_orig/src/core/surface.h DirectFB-1.7.7/src/core/surface.h
--- DirectFB-1.7.7_orig/src/core/surface.h	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/core/surface.h	2016-07-03 13:50:07.675744311 +0200
@@ -249,6 +249,9 @@
 
      CorePalette             *palette;
      GlobalReaction           palette_reaction;
+#if USE_RPC4DTV
+     int                      palette_updated;
+#endif
 
      FusionSHMPoolShared     *shmpool;
 
diff -ruNb DirectFB-1.7.7_orig/src/core/surface_pool.c DirectFB-1.7.7/src/core/surface_pool.c
--- DirectFB-1.7.7_orig/src/core/surface_pool.c	2015-02-09 18:16:46.000000000 +0100
+++ DirectFB-1.7.7/src/core/surface_pool.c	2016-07-03 13:50:07.675744311 +0200
@@ -868,7 +868,7 @@
      }
      else {
           /* Or take the generic approach via allocation list */
-          D_UNIMPLEMENTED();
+          //D_UNIMPLEMENTED();
      }
 
      /* FIXME: Solve potential dead lock, until then do a few retries... */
diff -ruNb DirectFB-1.7.7_orig/src/idirectfb.c DirectFB-1.7.7/src/idirectfb.c
--- DirectFB-1.7.7_orig/src/idirectfb.c	2015-02-01 20:36:12.000000000 +0100
+++ DirectFB-1.7.7/src/idirectfb.c	2016-07-03 13:50:21.319733612 +0200
@@ -590,11 +590,22 @@
 
      D_DEBUG_AT( IDFB, "  -> flags  0x%08x\n", desc->flags );
 
+	 //modified to support very long surface like 1x30000
+     if (desc->flags & DSDESC_WIDTH && desc->flags & DSDESC_HEIGHT) {
+          D_DEBUG_AT( IDFB, "  -> width  %d\n", desc->width );
+          D_DEBUG_AT( IDFB, "  -> height %d\n", desc->height );
+
+          width = desc->width;
+          height = desc->height;
+          if (width*height > 20480*20480)
+               return DFB_INVARG;
+     }
+
      if (desc->flags & DSDESC_WIDTH) {
           D_DEBUG_AT( IDFB, "  -> width  %d\n", desc->width );
 
           width = desc->width;
-          if (width < 1 || width > 20480)
+          if (width < 1)
                return DFB_INVARG;
      }
 
@@ -602,7 +613,7 @@
           D_DEBUG_AT( IDFB, "  -> height %d\n", desc->height );
 
           height = desc->height;
-          if (height < 1 || height > 20480)
+          if (height < 1)
                return DFB_INVARG;
      }
 
diff -ruNb DirectFB-1.7.7_orig/systems/devmem/devmem.c DirectFB-1.7.7/systems/devmem/devmem.c
--- DirectFB-1.7.7_orig/systems/devmem/devmem.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/devmem/devmem.c	2016-07-03 13:50:21.319733612 +0200
@@ -46,6 +46,11 @@
 
 #include <misc/conf.h>
 
+#if USE_RPC4DTV
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+
 #include "devmem.h"
 #include "surfacemanager.h"
 
@@ -58,10 +63,14 @@
 
 DFB_CORE_SYSTEM( devmem )
 
+
 /**********************************************************************************************************************/
 
 static DevMemData *m_data;    /* FIXME: Fix Core System API to pass data in all functions. */
-
+#if USE_RPC4DTV
+#define SHARED_MEMORY_KEY 902
+static int gShmid = 0;
+#endif
 /**********************************************************************************************************************/
 
 static DFBResult
@@ -73,11 +82,42 @@
 {
      int fd;
 
+#if USE_RPC4DTV
+     if(mem_phys == 0xffffffff)
+     {
+          gShmid = shmget((key_t)SHARED_MEMORY_KEY, mem_length, 0777|IPC_CREAT);
+          if(gShmid == -1)
+          {
+               D_PERROR( "System/DevMem: Opening shared memroy '%d' failed!\n", SHARED_MEMORY_KEY);
+               return DFB_INIT;
+          }
+
+          data->mem = shmat(gShmid, NULL, 0);
+          if(data->mem == (void *) -1)
+          {
+               D_PERROR( "System/DevMem: Getting shared memroy '%d' failed!\n", SHARED_MEMORY_KEY);
+          }
+
+          return DFB_OK;
+     }
+#endif
+
+#if DEVMEM_OFFSET_ADJUST
+	 unsigned int len_adjust;
+#endif
+
      fd = open( DEV_MEM, O_RDWR | O_SYNC );
      if (fd < 0) {
           D_PERROR( "System/DevMem: Opening '%s' failed!\n", DEV_MEM );
           return DFB_INIT;
      }
+#if DEVMEM_OFFSET_ADJUST
+	 {
+		 len_adjust = mem_phys & (sysconf(_SC_PAGE_SIZE) - 1);
+		 mem_phys -= len_adjust;
+		 mem_length += len_adjust;
+	 }
+#endif
 
      data->mem = mmap( NULL, mem_length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, mem_phys );
      if (data->mem == MAP_FAILED) {
@@ -85,6 +125,12 @@
           return DFB_INIT;
      }
 
+#if DEVMEM_OFFSET_ADJUST
+	 {
+		 data->mem += len_adjust;
+	 }
+#endif
+
      if (reg_phys && reg_length) {
           data->reg = mmap( NULL, reg_length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, reg_phys );
           if (data->reg == MAP_FAILED) {
@@ -109,6 +155,16 @@
                 unsigned int  mem_length,
                 unsigned int  reg_length )
 {
+#if USE_RPC4DTV
+     if(gShmid != 0)
+     {
+          if(shmdt(data->mem) == -1)
+          {
+               D_INFO( "System/DevMem: Detaching %d bytes at 0x%x via shared memory failed!\n", mem_length, data->mem );
+          }
+          return;
+	 }
+#endif
      munmap( data->mem, mem_length );
 
      if (reg_length)
@@ -136,7 +192,8 @@
 
      D_ASSERT( m_data == NULL );
 
-     if (!dfb_config->video_phys || !dfb_config->video_length) {
+     //if (!dfb_config->video_phys || !dfb_config->video_length) {
+     if (!dfb_config->video_length) {
           D_ERROR( "System/DevMem: Please supply 'video-phys = 0xXXXXXXXX' and 'video-length = XXXX' options!\n" );
           return DFB_INVARG;
      }
diff -ruNb DirectFB-1.7.7_orig/systems/devmem/devmem_surface_pool.c DirectFB-1.7.7/systems/devmem/devmem_surface_pool.c
--- DirectFB-1.7.7_orig/systems/devmem/devmem_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/devmem/devmem_surface_pool.c	2016-07-03 13:50:21.319733612 +0200
@@ -44,6 +44,11 @@
 #include "devmem.h"
 #include "surfacemanager.h"
 
+#if USE_RPC4DTV
+#include <pthread.h>
+extern pthread_mutex_t g_dlfcn_mutex;
+#endif
+
 D_DEBUG_DOMAIN( DevMem_Surfaces, "DevMem/Surfaces", "DevMem Framebuffer Surface Pool" );
 D_DEBUG_DOMAIN( DevMem_SurfLock, "DevMem/SurfLock", "DevMem Framebuffer Surface Pool Locks" );
 
@@ -271,7 +276,6 @@
                      void                  *alloc_data )
 {
      DFBResult             ret;
-     Chunk                *chunk;
      CoreSurface          *surface;
      DevMemPoolData       *data  = pool_data;
      DevMemPoolLocalData  *local = pool_local;
@@ -289,6 +293,108 @@
      surface = buffer->surface;
      D_MAGIC_ASSERT( surface, CoreSurface );
 
+     if ((surface->type & CSTF_LAYER)/* && surface->resource_id == DLID_PRIMARY*/)
+     {
+          int index  = dfb_surface_buffer_index( buffer );
+
+          D_DEBUG_AT( DevMem_Surfaces, "[%s:%d-%s] index = %d (surface->resource_id=%d)\n", __FUNCTION__, __LINE__, __FILE__, index, surface->resource_id);
+
+#if USE_VIRTUALFB
+          index = 0;
+#endif
+          alloc->pitch = MAX( surface->config.size.w, surface->config.min_size.w );
+          alloc->pitch = DFB_BYTES_PER_LINE( buffer->format, alloc->pitch );
+          alloc->size  = surface->config.size.h * alloc->pitch;
+#if !USE_RPC4DTV
+          alloc->offset = index * alloc->size;
+#else
+          int num_of_layers = 0;
+          if(!DDI_GPU_GetDeviceCapability || !DDI_GPU_GetLayerRegionInfo)
+          {
+               assign_symbol_DDI_GPU_FUNCS(&g_dlfcn_mutex);
+          }
+          
+          if(DDI_GPU_GetDeviceCapability)
+          {
+               GPU_DEVICE_CAPABILITY_INFO_T deviceCapability;
+               if( DDI_GPU_GetDeviceCapability(&deviceCapability) != OK)
+               {
+                    D_ERROR( "[%s:%d-%s]: DDI_GPU_GetDeviceCapability returns failure!\n",__FILE__, __LINE__,  __func__ );
+                    return DFB_FAILURE;
+               }
+               num_of_layers = deviceCapability.maxNumOfLayers;
+               D_DEBUG_AT( DevMem_Surfaces, "num_of_layers=%d\n", num_of_layers);
+          }
+          else
+          {
+               D_ERROR( "[%s:%d-%s]: Unable to call DDI_GPU_GetDeviceCapability()!\n",__FILE__, __LINE__,  __func__ );
+               return DFB_FAILURE;
+          }
+          D_DEBUG_AT( DevMem_Surfaces, "resource_id = %d\n", surface->resource_id);
+
+          if(DDI_GPU_GetLayerRegionInfo)
+          {
+               int i;
+               int skip_num = surface->resource_id;
+               GPU_LAYER_REGION_INFO_T layer_region_info;
+               for(i=0; i<num_of_layers; i++)
+               {
+                    if( DDI_GPU_GetLayerRegionInfo(i, &layer_region_info) != OK)
+                    {
+                         D_ERROR( "[%s:%d-%s]: DDI_GPU_GetLayerRegionInfo returns failure!\n",__FILE__, __LINE__,  __func__ );
+                         return DFB_FAILURE;
+                    }
+
+                    if(layer_region_info.property & GPU_PROPERTY_LAYER_FOR_DIRECTFB)
+                    {
+                         if(skip_num>0)
+                         {
+                              skip_num--;
+                              continue;
+                         }
+                         D_DEBUG_AT( DevMem_Surfaces, "layer[%d] is selected for resource_id(%d)\n", i, surface->resource_id);
+                         if((surface->resource_id == DLID_PRIMARY && index == 0) || (surface->resource_id != DLID_PRIMARY && index == 1))
+                         {
+                              alloc->offset = layer_region_info.surfaceInfo[0].offset;
+                              alloc->pitch = layer_region_info.surfaceInfo[0].pitch;
+                              alloc->size = layer_region_info.surfaceInfo[0].height * alloc->pitch;
+                         } else {
+                              if(layer_region_info.bUseDoubleBuffer)
+                              {
+                                   alloc->offset = layer_region_info.surfaceInfo[1].offset;
+                                   alloc->pitch = layer_region_info.surfaceInfo[1].pitch;
+                                   alloc->size = layer_region_info.surfaceInfo[1].height * alloc->pitch;
+                              }
+                              else
+                              {
+                                   alloc->offset = layer_region_info.surfaceInfo[0].offset;
+                                   alloc->pitch = layer_region_info.surfaceInfo[0].pitch;
+                                   alloc->size = layer_region_info.surfaceInfo[0].height * alloc->pitch;
+                              }
+                         }
+                         alloc->chunk = NULL;
+
+                         D_DEBUG_AT( DevMem_Surfaces, "  ->  index=%d, alloc: pitch:%d, size:%d, offset:0x%08x\n", index, alloc->pitch, alloc->size, alloc->offset);
+
+                         break;
+                    }
+                    else  //Only layer for DirectFB is needed.
+                    {
+                         D_DEBUG_AT( DevMem_Surfaces, "layer[%d] is discarded\n", i);
+                         continue;
+                    }
+               }
+          }
+          else
+          {
+               D_ERROR( "[%s:%d-%s]: Unable to call DDI_GPU_GetLayerRegionInfo()!\n",__FILE__, __LINE__,  __func__ );
+               return DFB_FAILURE;
+          }
+#endif
+     }
+     else {
+          Chunk *chunk;
+
      ret = dfb_surfacemanager_allocate( local->core, data->manager, buffer, allocation, &chunk );
      if (ret)
           return ret;
@@ -300,6 +406,7 @@
      alloc->size   = chunk->length;
 
      alloc->chunk  = chunk;
+     }
 
      D_DEBUG_AT( DevMem_Surfaces, "  -> offset %d, pitch %d, size %d\n", alloc->offset, alloc->pitch, alloc->size );
 
diff -ruNb DirectFB-1.7.7_orig/systems/devmem/Makefile.am DirectFB-1.7.7/systems/devmem/Makefile.am
--- DirectFB-1.7.7_orig/systems/devmem/Makefile.am	2013-07-17 04:49:59.000000000 +0200
+++ DirectFB-1.7.7/systems/devmem/Makefile.am	2016-07-03 13:50:21.319733612 +0200
@@ -14,6 +14,16 @@
 	devmem.h		\
 	surfacemanager.h
 
+if ENABLE_OFFSET_ADJUST
+AM_CFLAGS = -DDEVMEM_OFFSET_ADJUST=1
+if ENABLE_VIRTUALFB
+AM_CFLAGS += -DUSE_VIRTUALFB=1
+endif
+else
+if ENABLE_VIRTUALFB
+AM_CFLAGS = -DUSE_VIRTUALFB=1
+endif
+endif
 
 systemsdir = $(MODULEDIR)/systems
 
diff -ruNb DirectFB-1.7.7_orig/systems/devmem/surfacemanager.c DirectFB-1.7.7/systems/devmem/surfacemanager.c
--- DirectFB-1.7.7_orig/systems/devmem/surfacemanager.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/devmem/surfacemanager.c	2016-07-03 13:50:21.319733612 +0200
@@ -51,6 +51,19 @@
 
 #include "surfacemanager.h"
 
+#if USE_RPC4DTV
+#include <core/palette.h>
+#include <pthread.h>
+extern pthread_mutex_t g_dlfcn_mutex;
+static Chunk* alloc_chunk( SurfaceManager *manager, Chunk *c, int offset, int length );
+
+void dealloc_chunk(SurfaceManager *manager, Chunk* chunk);
+
+D_DEBUG_DOMAIN( SurfRPC, "RPC SurfaceManager", "DirectFB RPC Surface M" );
+#define D_PRINTF(x...) D_DEBUG_AT( SurfRPC, x )
+#endif
+
+
 D_DEBUG_DOMAIN( SurfMan, "SurfaceManager", "DirectFB Surface Manager" );
 
 
@@ -82,6 +95,13 @@
      D_ASSERT( core != NULL );
      D_ASSERT( ret_manager != NULL );
 
+#if USE_RPC4DTV
+     if(DDI_GPU_AllocSurface == NULL)
+     {
+          assign_symbol_DDI_GPU_FUNCS(&g_dlfcn_mutex);
+     }
+#endif
+
      pool = dfb_core_shmpool( core );
 
      manager = SHCALLOC( pool, 1, sizeof(SurfaceManager) );
@@ -151,6 +171,282 @@
                                        CoreSurfaceBuffer      *buffer,
                                        CoreSurfaceAllocation  *allocation,
                                        Chunk                 **ret_chunk )
+#if USE_RPC4DTV
+{
+     Chunk *c;
+
+     D_MAGIC_ASSERT( manager, SurfaceManager );
+     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
+     D_MAGIC_ASSERT( buffer->surface, CoreSurface );
+
+     if (ret_chunk)
+          D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+     else
+          D_ASSUME( allocation == NULL );
+
+     D_DEBUG_AT( SurfMan, "%s( %p ) <- %dx%d %s\n", __FUNCTION__, buffer,
+               buffer->surface->config.size.w, buffer->surface->config.size.h,
+               dfb_pixelformat_name( buffer->surface->config.format ) );
+
+     // check minimum size of surface
+	 if(!(buffer->surface->config.caps & DSCAPS_VIDEOONLY))
+	 {
+		 //if((buffer->surface->config.size.w * buffer->surface->config.size.h) < 256)  //18*18=324
+		 if((buffer->surface->config.size.w * buffer->surface->config.size.h) < 900)  //30*30=900 rule of thumb for bcm3549 platform. S/W blit is faster than H/W below.
+		 {
+			 D_PRINTF("The surface size is too small to be allocated in video memory.\n");
+			 return DFB_NOVIDEOMEMORY;
+		 }
+
+		 if(((buffer->surface->config.size.w * buffer->surface->config.size.h) < 2500) && (buffer->surface->config.size.w < 7))  // rule of thumb for bcm3549 platform. S/W blit is faster than H/W below.
+		 {
+			 D_PRINTF("The surface size and width is to small to be allocated in video memory.\n");
+			 return DFB_NOVIDEOMEMORY;
+		 }
+	 }
+
+#if 0 // 20081016_yducky -->
+     // can be skipped?
+     if (!ret_chunk)
+          return DFB_NOVIDEOMEMORY;
+#endif // 20081016_yducky <--
+
+     if (manager->suspended)
+          return DFB_SUSPENDED;
+
+     /* examine chunks */
+     c = manager->chunks;
+     D_MAGIC_ASSERT( c, Chunk );
+
+
+     if(DDI_GPU_AllocSurface == NULL)
+     {
+          assign_symbol_DDI_GPU_FUNCS(&g_dlfcn_mutex);
+     } 
+
+     if(DDI_GPU_AllocSurface != NULL)
+     {
+          CoreSurface *surface = buffer->surface;
+          GPU_SURFACE_INFO_T surfaceInfo;
+          unsigned short width = 0;
+          unsigned short height = 0;
+          GPU_PIXEL_FORMAT_T pixel_format = -1;
+
+          D_PRINTF("%s:%s:%d\n", __FILE__, __FUNCTION__, __LINE__);
+
+          D_PRINTF("width:%d, height:%d, format:%d \n", surface->config.size.w, surface->config.size.h, buffer->format);
+
+          width = surface->config.size.w;
+          height = surface->config.size.h;
+
+          switch(buffer->format)
+          {
+               case DSPF_UNKNOWN:
+                    D_PRINTF("format: DSPF_UNKNOWN\n");
+                    break;
+
+                    /* 16 bit  ARGB (2 byte, alpha 1@15, red 5@10, green 5@5, blue 5@0) */
+               case DSPF_ARGB1555:
+                    // br support!
+                    D_PRINTF("format: DSPF_ARGB1555\n");
+                    pixel_format = GPU_PIXEL_FORMAT_ARGB1555;
+                    break;
+
+                    /* 16 bit   RGB (2 byte, red 5@11, green 6@5, blue 5@0) */
+               case DSPF_RGB16:
+                    // br support!
+                    D_PRINTF("format: DSPF_RGB16\n"); 
+                    pixel_format = GPU_PIXEL_FORMAT_RGB16; 
+                    break;
+
+                    /* 24 bit   RGB (3 byte, red 8@16, green 8@8, blue 8@0) */
+               case DSPF_RGB24:
+                    D_PRINTF("format: DSPF_RGB24\n");
+                    break;
+
+                    /* 24 bit   RGB (4 byte, nothing@24, red 8@16, green 8@8, blue 8@0) */
+               case DSPF_RGB32:
+                    D_PRINTF("format: DSPF_RGB32\n");
+                    break;
+
+                    /* 32 bit  ARGB (4 byte, alpha 8@24, red 8@16, green 8@8, blue 8@0) */
+               case DSPF_ARGB:
+                    // br support!
+                    D_PRINTF("format: DSPF_ARGB\n");
+                    pixel_format = GPU_PIXEL_FORMAT_ARGB; 
+                    break;
+
+                    /*  8 bit alpha (1 byte, alpha 8@0), e.g. anti-aliased glyphs */
+               case DSPF_A8:
+                    D_PRINTF("format: DSPF_A8\n");
+                    pixel_format = GPU_PIXEL_FORMAT_A8; 
+                    break;
+
+                    /* 16 bit   YUV (4 byte/ 2 pixel, macropixel contains CbYCrY [31:0]) */
+               case DSPF_YUY2:
+                    D_PRINTF("format: DSPF_YUY2\n");
+                    break;
+
+                    /*  8 bit   RGB (1 byte, red 3@5, green 3@2, blue 2@0) */
+               case DSPF_RGB332:
+                    D_PRINTF("format: DSPF_RGB332\n");
+                    break;
+
+                    /* 16 bit   YUV (4 byte/ 2 pixel, macropixel contains YCbYCr [31:0]) */
+               case DSPF_UYVY:
+                    D_PRINTF("format: DSPF_UYVY\n");
+                    break;
+
+                    /* 12 bit   YUV (8 bit Y plane followed by 8 bit quarter size U/V planes) */
+               case DSPF_I420:
+                    D_PRINTF("format: DSPF_I420\n");
+                    break;
+
+                    /* 12 bit   YUV (8 bit Y plane followed by 8 bit quarter size V/U planes) */
+               case DSPF_YV12:
+                    D_PRINTF("format: DSPF_YV12\n");
+                    break;
+
+                    /*  8 bit   LUT (8 bit color and alpha lookup from palette) */
+               case DSPF_LUT8:
+                    D_PRINTF("format: DSPF_LUT8\n");
+                    pixel_format = GPU_PIXEL_FORMAT_LUT8;
+                    break;
+
+                    /*  8 bit  ALUT (1 byte, alpha 4@4, color lookup 4@0) */
+               case DSPF_ALUT44:
+                    D_PRINTF("format: DSPF_ALUT44\n");
+                    break;
+
+                    /* 32 bit  ARGB (4 byte, inv. alpha 8@24, red 8@16, green 8@8, blue 8@0) */
+               case DSPF_AiRGB:
+                    D_PRINTF("format: DSPF_AiRGB\n");
+                    break;
+
+                    /*  1 bit alpha (1 byte/ 8 pixel, most significant bit used first) */
+               case DSPF_A1:
+                    D_PRINTF("format: DSPF_A1\n");
+                    break;
+
+                    /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size CbCr [15:0] plane) */
+               case DSPF_NV12:
+                    D_PRINTF("format: DSPF_NV12\n");
+                    break;
+
+                    /* 16 bit   YUV (8 bit Y plane followed by one 16 bit half width CbCr [15:0] plane) */
+               case DSPF_NV16:
+                    D_PRINTF("format: DSPF_NV16\n");
+                    break;
+
+                    /* 16 bit  ARGB (2 byte, alpha 2@14, red 5@9, green 5@4, blue 4@0) */
+               case DSPF_ARGB2554:
+                    D_PRINTF("format: DSPF_ARGB2554\n");
+                    break;
+
+                    /* 16 bit  ARGB (2 byte, alpha 4@12, red 4@8, green 4@4, blue 4@0) */
+               case DSPF_ARGB4444:
+                    // br support!
+                    D_PRINTF("format: DSPF_ARGB4444\n");
+                    pixel_format = GPU_PIXEL_FORMAT_ARGB4444;   
+                    break;
+
+                    /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size CrCb [15:0] plane) */
+               case DSPF_NV21:
+                    D_PRINTF("format: DSPF_NV21\n");
+                    break;
+
+                    /* 32 bit  AYUV (4 byte, alpha 8@24, Y 8@16, Cb 8@8, Cr 8@0) */
+               case DSPF_AYUV:
+                    D_PRINTF("format: DSPF_AYUV\n");
+                    break;
+
+                    /*  4 bit alpha (1 byte/ 2 pixel, more significant nibble used first) */
+               case DSPF_A4:
+                    D_PRINTF("format: DSPF_A4\n");
+                    break;
+
+                    /*  1 bit alpha (3 byte/  alpha 1@18, red 6@16, green 6@6, blue 6@0) */
+               case DSPF_ARGB1666:
+                    D_PRINTF("format: DSPF_ARGB1666\n");
+                    break;
+
+                    /*  6 bit alpha (3 byte/  alpha 6@18, red 6@16, green 6@6, blue 6@0) */
+               case DSPF_ARGB6666:
+                    D_PRINTF("format: DSPF_ARGB6666\n");
+                    break;
+
+                    /*  6 bit   RGB (3 byte/   red 6@16, green 6@6, blue 6@0) */
+               case DSPF_RGB18:
+                    D_PRINTF("format: DSPF_RGB18\n");
+                    break;
+
+                    /*  2 bit   LUT (1 byte/ 4 pixel, 2 bit color and alpha lookup from palette) */
+               case DSPF_LUT2:
+                    D_PRINTF("format: DSPF_LUT2\n");
+                    break;
+
+                    /* 16 bit   RGB (2 byte, nothing @12, red 4@8, green 4@4, blue 4@0) */
+               case DSPF_RGB444:
+                    D_PRINTF("format: DSPF_RGB444\n");
+                    break;
+
+                    /* 16 bit   RGB (2 byte, nothing @15, red 5@10, green 5@5, blue 5@0) */
+               case DSPF_RGB555:
+                    D_PRINTF("format: DSPF_RGB555\n");
+                    break;
+
+                    /* 16 bit   BGR (2 byte, nothing @15, blue 5@10, green 5@5, red 5@0) */
+               case DSPF_BGR555:
+                    D_PRINTF("format: DSPF_BGR555\n");
+                    break;
+
+               default:
+                    D_PRINTF("format: Unknown!\n");
+                    break;
+          }
+
+          // Call DDI_GPU_AllocSurface! 
+          if(pixel_format == -1)
+          {
+               return DFB_NOVIDEOMEMORY;
+          }
+
+          if(DDI_GPU_AllocSurface(width, height, pixel_format, &surfaceInfo) != OK)
+          {
+               return DFB_NOVIDEOMEMORY;
+          }
+
+          D_PRINTF("pitch = %d, bpp = %d, offset = 0x%x\n", surfaceInfo.pitch, surfaceInfo.bpp, surfaceInfo.offset);
+
+          /* NULL means check only. */
+          if (ret_chunk)
+          {
+               *ret_chunk = alloc_chunk( manager, c, surfaceInfo.offset, surfaceInfo.pitch*height );
+               (*ret_chunk)->allocation = allocation;
+               (*ret_chunk)->buffer     = allocation->buffer;
+               (*ret_chunk)->pitch      = surfaceInfo.pitch;
+               (*ret_chunk)->surface_info = surfaceInfo;
+          }
+          else
+          {
+               //D_WARN("You can NOT be here!!!\n");
+               DDI_GPU_DeallocSurface(surfaceInfo);
+               return DFB_OK;
+          }
+
+          manager->min_toleration++;
+
+          //D_PRINTF("chunk.pitch = %d, chunk.offset = 0x%x, chunk.id = %d\n", surface.pitch, surface.offset, surface.id);
+          //    buffer->video.chunk->buffer = buffer;
+
+          return DFB_OK;
+     }
+     else    
+     {
+          return DFB_NOVIDEOMEMORY;
+     }
+}
+#else
 {
      int pitch;
      int length;
@@ -181,7 +477,7 @@
 
      dfb_gfxcard_calc_buffer_size( device, buffer, &pitch, &length );
 
-     D_DEBUG_AT( SurfMan, "  -> pitch %d, length %d\n", pitch, length );
+     D_DEBUG_AT( SurfMan, "  -> avail %d, pitch %d, length %d\n", manager->avail, pitch, length );
 
      if (manager->avail < length)
           return DFB_TEMPUNAVAIL;
@@ -240,6 +536,7 @@
      /* no luck */
      return DFB_NOVIDEOMEMORY;
 }
+#endif
 
 DFBResult dfb_surfacemanager_displace( CoreDFB           *core,
                                        SurfaceManager    *manager,
@@ -268,6 +565,9 @@
                  buffer->surface->config.size.w, buffer->surface->config.size.h,
                  dfb_pixelformat_name( buffer->surface->config.format ) );
 
+#if USE_RPC4DTV
+	return DFB_NOVIDEOMEMORY;
+#endif
      /* FIXME: Only one global device at the moment. */
      device = dfb_core_get_part( core, DFCP_GRAPHICS );
      D_ASSERT( device != NULL );
@@ -456,7 +756,17 @@
                  buffer->surface->config.size.w, buffer->surface->config.size.h,
                  dfb_pixelformat_name( buffer->surface->config.format ) );
 
+#if USE_RPC4DTV
+     if(DDI_GPU_DeallocSurface)
+     {
+          GPU_SURFACE_INFO_T surfaceInfo;
+
+          DDI_GPU_DeallocSurface(chunk->surface_info);
+          dealloc_chunk(manager, chunk);
+     }
+#else
      free_chunk( manager, chunk );
+#endif
 
      return DFB_OK;
 }
@@ -582,3 +892,53 @@
      return chunk;
 }
 
+#if USE_RPC4DTV
+static Chunk* alloc_chunk( SurfaceManager *manager, Chunk *c, int offset, int length )
+{
+     Chunk *newchunk;
+
+     newchunk = (Chunk*) SHCALLOC( manager->shmpool, 1, sizeof(Chunk) );
+
+     /* calculate offsets and lengths of resulting chunks */
+     newchunk->offset = offset;
+     newchunk->length = length;
+
+     /* insert newchunk after chunk c */
+     newchunk->prev = c;
+     newchunk->next = c->next;
+     if (c->next)
+          c->next->prev = newchunk;
+     c->next = newchunk;
+
+     D_MAGIC_SET( newchunk, Chunk );
+
+     return newchunk;
+}
+
+void dealloc_chunk(SurfaceManager *manager, Chunk* chunk)
+{
+
+     if (chunk->buffer->policy == CSP_VIDEOONLY)
+          manager->avail += chunk->length;
+
+     chunk->allocation = NULL;
+     chunk->buffer     = NULL;
+
+     manager->min_toleration--;
+
+     /* delete chunk from list */
+     if(chunk->prev)
+     {
+          Chunk *prev = chunk->prev;
+          prev->next = chunk->next;
+
+          if(chunk->next)
+               chunk->next->prev = prev;
+
+          D_MAGIC_CLEAR( chunk );
+          SHFREE(manager->shmpool, chunk);
+          chunk = prev;
+     }
+
+}
+#endif
diff -ruNb DirectFB-1.7.7_orig/systems/devmem/surfacemanager.h DirectFB-1.7.7/systems/devmem/surfacemanager.h
--- DirectFB-1.7.7_orig/systems/devmem/surfacemanager.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/devmem/surfacemanager.h	2016-07-03 13:50:21.319733612 +0200
@@ -37,6 +37,10 @@
 
 #include <core/coretypes.h>
 
+#if USE_RPC4DTV
+#include "ddi_gpu.h"
+#endif
+
 typedef struct _SurfaceManager SurfaceManager;
 typedef struct _Chunk          Chunk;
 
@@ -63,6 +67,10 @@
 
      Chunk               *prev;
      Chunk               *next;
+
+#if USE_RPC4DTV
+     GPU_SURFACE_INFO_T  surface_info;
+#endif
 };
 
 struct _SurfaceManager {
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/fbdev.c DirectFB-1.7.7/systems/fbdev/fbdev.c
--- DirectFB-1.7.7_orig/systems/fbdev/fbdev.c	2015-02-01 20:42:59.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/fbdev.c	2016-07-03 21:55:48.505785085 +0200
@@ -124,9 +124,9 @@
 
 /******************************************************************************/
 
-static int       primaryLayerDataSize ( void );
+static int       primaryLayerDataSize ();
 
-static int       primaryRegionDataSize( void );
+static int       primaryRegionDataSize();
 
 static DFBResult primaryInitLayer     ( CoreLayer                  *layer,
                                         void                       *driver_data,
@@ -181,17 +181,17 @@
 
 
 static DisplayLayerFuncs primaryLayerFuncs = {
-     .LayerDataSize      = primaryLayerDataSize,
-     .RegionDataSize     = primaryRegionDataSize,
-     .InitLayer          = primaryInitLayer,
-
-     .SetColorAdjustment = primarySetColorAdjustment,
-
-     .TestRegion         = primaryTestRegion,
-     .AddRegion          = primaryAddRegion,
-     .SetRegion          = primarySetRegion,
-     .RemoveRegion       = primaryRemoveRegion,
-     .FlipRegion         = primaryFlipRegion,
+     LayerDataSize:      primaryLayerDataSize,
+     RegionDataSize:     primaryRegionDataSize,
+     InitLayer:          primaryInitLayer,
+
+     SetColorAdjustment: primarySetColorAdjustment,
+
+     TestRegion:         primaryTestRegion,
+     AddRegion:          primaryAddRegion,
+     SetRegion:          primarySetRegion,
+     RemoveRegion:       primaryRemoveRegion,
+     FlipRegion:         primaryFlipRegion,
 };
 
 /******************************************************************************/
@@ -247,9 +247,7 @@
 static DFBResult dfb_fbdev_test_mode_simple( const VideoMode             *mode );
 
 static DFBResult dfb_fbdev_set_mode        ( const VideoMode             *mode,
-                                             CoreSurface                 *surface,
-                                             unsigned int                 xoffset,
-                                             unsigned int                 yoffset );
+                                             const CoreSurfaceConfig     *config );
 
 /******************************************************************************/
 
@@ -279,7 +277,7 @@
 
 /******************************************************************************/
 
-static DFBResult dfb_fbdev_open( void )
+static DFBResult dfb_fbdev_open()
 {
      DFBResult error_result = DFB_FAILURE;
 
@@ -660,8 +658,6 @@
      }
 
      dfb_fbdev = D_CALLOC( 1, sizeof(FBDev) );
-     if (!dfb_fbdev)
-          return D_OOM();
 
      core_arena_get_shared_field( core, "fbdev", &shared );
 
@@ -813,13 +809,13 @@
 }
 
 static DFBResult
-system_suspend( void )
+system_suspend()
 {
      return DFB_OK;
 }
 
 static DFBResult
-system_resume( void )
+system_resume()
 {
      return DFB_OK;
 }
@@ -861,7 +857,7 @@
 }
 
 static int
-system_get_accelerator( void )
+system_get_accelerator()
 {
 #ifdef FB_ACCEL_MATROX_MGAG400
      if (!strcmp( dfb_fbdev->shared->fix.id, "MATROX DH" ))
@@ -879,19 +875,19 @@
 }
 
 static VideoMode *
-system_get_modes( void )
+system_get_modes()
 {
      return dfb_fbdev->shared->modes;
 }
 
 static VideoMode *
-system_get_current_mode( void )
+system_get_current_mode()
 {
      return &dfb_fbdev->shared->current_mode;
 }
 
 static DFBResult
-system_thread_init( void )
+system_thread_init()
 {
      if (dfb_config->block_all_signals)
           direct_signals_block_all();
@@ -940,7 +936,7 @@
 }
 
 static unsigned int
-system_videoram_length( void )
+system_videoram_length()
 {
      return dfb_fbdev->shared->fix.smem_len;
 }
@@ -962,7 +958,7 @@
 }
 
 static unsigned int
-system_auxram_length( void )
+system_auxram_length()
 {
      if (dfb_fbdev->shared->agp)
           return dfb_fbdev->shared->agp->agp_mem;
@@ -1007,7 +1003,7 @@
 /******************************************************************************/
 
 static DFBResult
-init_modes( void )
+init_modes()
 {
      dfb_fbdev_read_modes();
 
@@ -1015,8 +1011,6 @@
           /* try to use current mode*/
           dfb_fbdev->shared->modes = (VideoMode*) SHCALLOC( dfb_fbdev->shared->shmpool,
                                                             1, sizeof(VideoMode) );
-          if (!dfb_fbdev->shared->modes)
-               return D_OOSHM();
 
           *dfb_fbdev->shared->modes = dfb_fbdev->shared->current_mode;
 
@@ -1160,13 +1154,13 @@
 /******************************************************************************/
 
 static int
-primaryLayerDataSize( void )
+primaryLayerDataSize()
 {
      return 0;
 }
 
 static int
-primaryRegionDataSize( void )
+primaryRegionDataSize()
 {
      return 0;
 }
@@ -1210,8 +1204,8 @@
      config->flags      = DLCONF_WIDTH       | DLCONF_HEIGHT |
                           DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE;
      config->buffermode = DLBM_FRONTONLY;
-     config->width      = dfb_config->mode.width  ? dfb_config->mode.width  : default_mode->xres;
-     config->height     = dfb_config->mode.height ? dfb_config->mode.height : default_mode->yres;
+     config->width      = default_mode->xres;
+     config->height     = default_mode->yres;
 
      if (dfb_config->mode.format)
           config->pixelformat = dfb_config->mode.format;
@@ -1394,10 +1388,6 @@
      if (config->options)
           fail |= CLRCF_OPTIONS;
 
-     if ((config->source.x && !shared->fix.xpanstep) ||
-         (config->source.y && !shared->fix.ypanstep && !shared->fix.ywrapstep))
-          fail |= CLRCF_SOURCE;
-
      if (failed)
           *failed = fail;
 
@@ -1457,8 +1447,7 @@
                     mode = &dummy;
                }
 
-               ret = dfb_fbdev_set_mode( mode, surface, config->source.x,
-                                         left_lock->offset / left_lock->pitch + config->source.y );
+               ret = dfb_fbdev_set_mode( mode, &surface->config );
                if (ret)
                     return ret;
           }
@@ -1562,9 +1551,6 @@
      struct fb_var_screeninfo *var;
      FBDevShared              *shared = dfb_fbdev->shared;
 
-     if (!shared->fix.xpanstep && !shared->fix.ypanstep && !shared->fix.ywrapstep)
-          return DFB_OK;
-
      var = &shared->current_var;
 
      if (var->xres_virtual < xoffset + var->xres) {
@@ -1581,20 +1567,18 @@
           return DFB_BUG;
      }
 
-     if (shared->fix.xpanstep)
-          var->xoffset = xoffset - (xoffset % shared->fix.xpanstep);
+     if (dfb_fbdev->shared->fix.xpanstep)
+          var->xoffset = xoffset - (xoffset % dfb_fbdev->shared->fix.xpanstep);
      else
           var->xoffset = 0;
 
-     if (shared->fix.ywrapstep) {
-          var->yoffset = yoffset - (yoffset % shared->fix.ywrapstep);
+     if (dfb_fbdev->shared->fix.ywrapstep) {
+          var->yoffset = yoffset - (yoffset % dfb_fbdev->shared->fix.ywrapstep);
           var->vmode |= FB_VMODE_YWRAP;
-     }
-     else if (shared->fix.ypanstep) {
-          var->yoffset = yoffset - (yoffset % shared->fix.ypanstep);
+     } else if (dfb_fbdev->shared->fix.ypanstep) {
+          var->yoffset = yoffset - (yoffset % dfb_fbdev->shared->fix.ypanstep);
           var->vmode &= ~FB_VMODE_YWRAP;
-     }
-     else {
+     } else {
           var->yoffset = 0;
      }
 
@@ -1616,7 +1600,7 @@
                     (var->vmode & FB_VMODE_YWRAP) ? 1 : 0,
                     (var->activate & FB_ACTIVATE_VBL) ? 1 : 0);
 
-          return errno2result(result);
+         // return errno2result(result);
      }
 
      return DFB_OK;
@@ -1637,13 +1621,11 @@
      return DFB_OK;
 }
 
-static DFBResult
+DFBResult
 dfb_fbdev_mode_to_var( const VideoMode           *mode,
                        DFBSurfacePixelFormat      pixelformat,
                        unsigned int               vxres,
                        unsigned int               vyres,
-                       unsigned int               xoffset,
-                       unsigned int               yoffset,
                        DFBDisplayLayerBufferMode  buffermode,
                        struct fb_var_screeninfo  *ret_var )
 {
@@ -1682,17 +1664,7 @@
      var.yres         = mode->yres;
      var.xres_virtual = vxres;
      var.yres_virtual = vyres;
-
-     if (shared->fix.xpanstep)
-          var.xoffset = xoffset - (xoffset % shared->fix.xpanstep);
-     else
           var.xoffset = 0;
-
-     if (shared->fix.ywrapstep)
-          var.yoffset = yoffset - (yoffset % shared->fix.ywrapstep);
-     else if (shared->fix.ypanstep)
-          var.yoffset = yoffset - (yoffset % shared->fix.ypanstep);
-     else
           var.yoffset = 0;
 
      /* Set buffer mode */
@@ -1940,8 +1912,7 @@
      if (source->h != mode->yres && shared->fix.ypanstep == 0 && shared->fix.ywrapstep == 0)
           return DFB_UNSUPPORTED;
 
-     ret = dfb_fbdev_mode_to_var( mode, config->format, config->width, config->height,
-                                  0, 0, config->buffermode, &var );
+     ret = dfb_fbdev_mode_to_var( mode, config->format, config->width, config->height, config->buffermode, &var );
      if (ret)
           return ret;
 
@@ -1984,8 +1955,8 @@
 
      D_ASSERT( mode != NULL );
 
-     ret = dfb_fbdev_mode_to_var( mode, dfb_pixelformat_for_depth(mode->bpp), mode->xres, mode->yres,
-                                  0, 0, DLBM_FRONTONLY, &var );
+     ret = dfb_fbdev_mode_to_var( mode, dfb_pixelformat_for_depth(mode->bpp),
+                                  mode->xres, mode->yres, DLBM_FRONTONLY, &var );
      if (ret)
           return ret;
 
@@ -2017,9 +1988,7 @@
 
 static DFBResult
 dfb_fbdev_set_mode( const VideoMode         *mode,
-                    CoreSurface             *surface,
-                    unsigned int             xoffset,
-                    unsigned int             yoffset )
+                    const CoreSurfaceConfig *config )
 {
      DFBResult                  ret;
      int                        bufs;
@@ -2027,32 +1996,18 @@
      struct fb_var_screeninfo   var2;
      FBDevShared               *shared     = dfb_fbdev->shared;
      DFBDisplayLayerBufferMode  buffermode = DLBM_FRONTONLY;
-     const CoreSurfaceConfig   *config     = &surface->config;
 
      D_DEBUG_AT( FBDev_Mode, "%s( mode: %p, config: %p )\n", __FUNCTION__, mode, config );
 
      D_ASSERT( mode != NULL );
      D_ASSERT( config != NULL );
 
-     bufs = num_video_buffers( surface );
-     switch (bufs) {
-          case 3:
-               buffermode = DLBM_TRIPLE;
-               break;
-          case 2:
+     if (config->caps & DSCAPS_DOUBLE)
                buffermode = DLBM_BACKVIDEO;
-               break;
-          case 1:
-               buffermode = DLBM_FRONTONLY;
-               break;
-          default:
-               D_BUG( "dfb_fbdev_set_mode() called with %d video buffers!", bufs );
-               return DFB_BUG;
-     }
-
+     else if (config->caps & DSCAPS_TRIPLE)
+               buffermode = DLBM_TRIPLE;
 
-     ret = dfb_fbdev_mode_to_var( mode, config->format, config->size.w, config->size.h,
-                                  xoffset, yoffset, buffermode, &var );
+     ret = dfb_fbdev_mode_to_var( mode, config->format, config->size.w, config->size.h, buffermode, &var );
      if (ret) {
           D_ERROR( "FBDev/Mode: Failed to switch to %dx%d %s (buffermode %d)\n",
                    config->size.w, config->size.h, dfb_pixelformat_name(config->format), buffermode );
@@ -2135,7 +2090,7 @@
  * (to be replaced by DirectFB's own config system
  */
 static DFBResult
-dfb_fbdev_read_modes( void )
+dfb_fbdev_read_modes()
 {
      FILE        *fp;
      char         line[80],label[32],value[16];
@@ -2143,7 +2098,7 @@
      int          dummy;
      VideoMode    temp_mode;
      FBDevShared *shared = dfb_fbdev->shared;
-     VideoMode   *prev   = shared->modes;
+     VideoMode   *m      = shared->modes;
 
      D_DEBUG_AT( FBDev_Mode, "%s()\n", __FUNCTION__ );
 
@@ -2192,20 +2147,16 @@
                }
 
                if (geometry && timings && !dfb_fbdev_test_mode_simple(&temp_mode)) {
-                    VideoMode *mode = SHCALLOC( shared->shmpool, 1, sizeof(VideoMode) );
-                    if (!mode) {
-                         D_OOSHM();
-                         continue;
+                    if (!m) {
+                         shared->modes = SHCALLOC( shared->shmpool, 1, sizeof(VideoMode) );
+                         m = shared->modes;
+                    }
+                    else {
+                         m->next = SHCALLOC( shared->shmpool, 1, sizeof(VideoMode) );
+                         m = m->next;
                     }
 
-                    if (!prev)
-                         shared->modes = mode;
-                    else
-                         prev->next = mode;
-
-                    direct_memcpy (mode, &temp_mode, sizeof(VideoMode));
-
-                    prev = mode;
+                    direct_memcpy (m, &temp_mode, sizeof(VideoMode));
 
                     D_DEBUG_AT( FBDev_Mode, " +-> %16s %4dx%4d  %s%s\n", label, temp_mode.xres, temp_mode.yres,
                                 temp_mode.laced ? "interlaced " : "", temp_mode.doubled ? "doublescan" : "" );
@@ -2370,9 +2321,8 @@
 }
 
 static DFBResult
-dfb_fbdev_set_rgb332_palette( void )
+dfb_fbdev_set_rgb332_palette()
 {
-     DFBResult ret = DFB_OK;
      int red_val;
      int green_val;
      int blue_val;
@@ -2390,24 +2340,10 @@
      cmap.start  = 0;
      cmap.len    = 256;
      cmap.red    = (u16*)SHMALLOC( pool, 2 * 256 );
-     if (!cmap.red) {
-          return D_OOSHM();
-     }
      cmap.green  = (u16*)SHMALLOC( pool, 2 * 256 );
-     if (!cmap.green) {
-          ret = D_OOSHM();
-          goto free_red;
-     }
      cmap.blue   = (u16*)SHMALLOC( pool, 2 * 256 );
-     if (!cmap.blue) {
-          ret = D_OOSHM();
-          goto free_green;
-     }
      cmap.transp = (u16*)SHMALLOC( pool, 2 * 256 );
-     if (!cmap.transp) {
-          ret = D_OOSHM();
-          goto free_blue;
-     }
+
 
      for (red_val = 0; red_val  < 8 ; red_val++) {
           for (green_val = 0; green_val  < 8 ; green_val++) {
@@ -2424,20 +2360,21 @@
      if (FBDEV_IOCTL( FBIOPUTCMAP, &cmap ) < 0) {
           D_PERROR( "DirectFB/FBDev: "
                      "Could not set rgb332 palette" );
-          ret = errno2result(errno);
-          goto free_transp;
-     }
 
- free_transp:
-     SHFREE( pool, cmap.transp );
- free_blue:
-     SHFREE( pool, cmap.blue );
- free_green:
+          SHFREE( pool, cmap.red );
      SHFREE( pool, cmap.green );
- free_red:
+          SHFREE( pool, cmap.blue );
+          SHFREE( pool, cmap.transp );
+
+          return errno2result(errno);
+     }
+
      SHFREE( pool, cmap.red );
+     SHFREE( pool, cmap.green );
+     SHFREE( pool, cmap.blue );
+     SHFREE( pool, cmap.transp );
 
-     return ret;
+     return DFB_OK;
 }
 
 static FusionCallHandlerResult
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/fbdev_surface_pool.c DirectFB-1.7.7/systems/fbdev/fbdev_surface_pool.c
--- DirectFB-1.7.7_orig/systems/fbdev/fbdev_surface_pool.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/fbdev_surface_pool.c	2016-07-03 13:50:21.323733609 +0200
@@ -72,19 +72,19 @@
 /**********************************************************************************************************************/
 
 static int
-fbdevPoolDataSize( void )
+fbdevPoolDataSize()
 {
      return sizeof(FBDevPoolData);
 }
 
 static int
-fbdevPoolLocalDataSize( void )
+fbdevPoolLocalDataSize()
 {
      return sizeof(FBDevPoolLocalData);
 }
 
 static int
-fbdevAllocationDataSize( void )
+fbdevAllocationDataSize()
 {
      return sizeof(FBDevAllocationData);
 }
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/Makefile.in DirectFB-1.7.7/systems/fbdev/Makefile.in
--- DirectFB-1.7.7_orig/systems/fbdev/Makefile.in	2015-02-11 15:44:31.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/Makefile.in	2016-07-03 13:50:21.319733612 +0200
@@ -286,6 +286,7 @@
 FLUXCOMP = @FLUXCOMP@
 FLUXED_ARGS_BYTES = @FLUXED_ARGS_BYTES@
 FREETYPE_CFLAGS = @FREETYPE_CFLAGS@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
 FREETYPE_LIBS = @FREETYPE_LIBS@
 FREETYPE_PROVIDER = @FREETYPE_PROVIDER@
 FS_MAX_CHANNELS = @FS_MAX_CHANNELS@
@@ -378,6 +379,7 @@
 RTLIB = @RTLIB@
 RUNTIME_SYSROOT = @RUNTIME_SYSROOT@
 SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
 SDL_LIBS = @SDL_LIBS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/surfacemanager.c DirectFB-1.7.7/systems/fbdev/surfacemanager.c
--- DirectFB-1.7.7_orig/systems/fbdev/surfacemanager.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/surfacemanager.c	2016-07-03 13:50:21.323733609 +0200
@@ -514,10 +514,6 @@
           return c;
 
      newchunk = (Chunk*) SHCALLOC( manager->shmpool, 1, sizeof(Chunk) );
-     if (!newchunk) {
-          D_OOSHM();
-          return NULL;
-     }
 
      /* calculate offsets and lengths of resulting chunks */
      newchunk->offset = c->offset + c->length - length;
@@ -609,8 +605,6 @@
           manager->avail -= length;
 
      chunk = split_chunk( manager, chunk, length );
-     if (!chunk)
-          return NULL;
 
      D_DEBUG_AT( SurfMan, "%s( %d bytes at offset %d )\n", __FUNCTION__, chunk->length, chunk->offset );
 
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/vt.c DirectFB-1.7.7/systems/fbdev/vt.c
--- DirectFB-1.7.7_orig/systems/fbdev/vt.c	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/vt.c	2016-07-03 13:50:21.327733606 +0200
@@ -113,8 +113,6 @@
      D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
 
      dfb_vt = D_CALLOC( 1, sizeof(VirtualTerminal) );
-     if (!dfb_vt)
-          return D_OOM();
 
      setsid();
      dfb_vt->fd0 = open( "/dev/tty0", O_RDONLY | O_NOCTTY );
@@ -237,7 +235,7 @@
 }
 
 DFBResult
-dfb_vt_join( void )
+dfb_vt_join()
 {
      D_DEBUG_AT( VT, "%s()\n", __FUNCTION__ );
 
@@ -462,7 +460,7 @@
 }
 
 static DFBResult
-vt_init_switching( void )
+vt_init_switching()
 {
      struct termios ts;
      const char cursoroff_str[] = "\033[?1;0;0c";
diff -ruNb DirectFB-1.7.7_orig/systems/fbdev/vt.h DirectFB-1.7.7/systems/fbdev/vt.h
--- DirectFB-1.7.7_orig/systems/fbdev/vt.h	2013-12-19 01:16:24.000000000 +0100
+++ DirectFB-1.7.7/systems/fbdev/vt.h	2016-07-03 13:50:21.327733606 +0200
@@ -71,8 +71,8 @@
 /*
  * allocates and switches to a new virtual terminal
  */
-DFBResult dfb_vt_initialize( void );
-DFBResult dfb_vt_join( void );
+DFBResult dfb_vt_initialize();
+DFBResult dfb_vt_join();
 
 /*
  * deallocates virtual terminal
